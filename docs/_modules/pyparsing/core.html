<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyparsing.core &mdash; ASE2SPRKKR  documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mods.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ASE2SPRKKR
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">How to use the package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how-to-install.html">More about the package installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../philosophy.html">Philosophy of the package (for developers)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference external" href="_static/slides.pdf#http://">Hastily written ASE2SPRKKR slides</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://ase2sprkkr.github.io/ase2sprkkr/">ASE2SPRKKR homepage</a></li>
<li class="toctree-l1"><a class="reference external" href="https://wiki.fysik.dtu.dk/ase/">ASE - atomic simulation environment</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ebert.cup.uni-muenchen.de/index.php/en/software-en/13-sprkkr">SPR-KKR</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/ase2sprkkr/ase2sprkkr">GitHub repository</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.org/project/ase2sprkkr">PyPI package</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.ebert.cup.uni-muenchen.de/index.php/en/repository/func-startdown/251/lang,en-gb/">SPR-KKR manual</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Class documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../auto/ase2sprkkr.html">ase2sprkkr</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ASE2SPRKKR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyparsing.core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyparsing.core</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># core.py</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">NamedTuple</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Generator</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">TextIO</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">RLock</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_FifoCache</span><span class="p">,</span>
    <span class="n">_UnboundedCache</span><span class="p">,</span>
    <span class="n">__config_flags</span><span class="p">,</span>
    <span class="n">_collapse_string_to_ranges</span><span class="p">,</span>
    <span class="n">_escape_regex_range_chars</span><span class="p">,</span>
    <span class="n">_bslash</span><span class="p">,</span>
    <span class="n">_flatten</span><span class="p">,</span>
    <span class="n">LRUMemo</span> <span class="k">as</span> <span class="n">_LRUMemo</span><span class="p">,</span>
    <span class="n">UnboundedMemo</span> <span class="k">as</span> <span class="n">_UnboundedMemo</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.actions</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.results</span> <span class="kn">import</span> <span class="n">ParseResults</span><span class="p">,</span> <span class="n">_ParseResultsWithOffset</span>
<span class="kn">from</span> <span class="nn">.unicode</span> <span class="kn">import</span> <span class="n">pyparsing_unicode</span>

<span class="n">_MAX_INT</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
<span class="n">str_type</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># Copyright (c) 2003-2022  Paul T. McGuire</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="c1"># a copy of this software and associated documentation files (the</span>
<span class="c1"># &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="c1"># without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="c1"># distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="c1"># permit persons to whom the Software is furnished to do so, subject to</span>
<span class="c1"># the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be</span>
<span class="c1"># included in all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="c1"># EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="c1"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.</span>
<span class="c1"># IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY</span>
<span class="c1"># CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,</span>
<span class="c1"># TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE</span>
<span class="c1"># SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="c1">#</span>


<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cached_property</span>
<span class="k">else</span><span class="p">:</span>

    <span class="k">class</span> <span class="nc">cached_property</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>

        <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">__compat__</span><span class="p">(</span><span class="n">__config_flags</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A cross-version compatibility configuration for pyparsing features that will be</span>
<span class="sd">    released in a future version. By setting values in this configuration to True,</span>
<span class="sd">    those features can be enabled in prior versions for compatibility development</span>
<span class="sd">    and testing.</span>

<span class="sd">    - ``collect_all_And_tokens`` - flag to enable fix for Issue #63 that fixes erroneous grouping</span>
<span class="sd">      of results names when an :class:`And` expression is nested within an :class:`Or` or :class:`MatchFirst`;</span>
<span class="sd">      maintained for compatibility, but setting to ``False`` no longer restores pre-2.3.1</span>
<span class="sd">      behavior</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_type_desc</span> <span class="o">=</span> <span class="s2">&quot;compatibility&quot;</span>

    <span class="n">collect_all_And_tokens</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">_all_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">__</span> <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>
    <span class="n">_fixed_names</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        collect_all_And_tokens</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">__diag__</span><span class="p">(</span><span class="n">__config_flags</span><span class="p">):</span>
    <span class="n">_type_desc</span> <span class="o">=</span> <span class="s2">&quot;diagnostic&quot;</span>

    <span class="n">warn_multiple_tokens_in_named_alternation</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warn_ungrouped_named_tokens_in_collection</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warn_name_set_on_empty_Forward</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warn_on_parse_using_empty_Forward</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warn_on_assignment_to_Forward</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warn_on_multiple_string_args_to_oneof</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warn_on_match_first_with_lshift_operator</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">enable_debug_on_named_expressions</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_all_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">__</span> <span class="k">for</span> <span class="n">__</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)]</span>
    <span class="n">_warning_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_all_names</span> <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;warn&quot;</span><span class="p">)]</span>
    <span class="n">_debug_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_all_names</span> <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;enable_debug&quot;</span><span class="p">)]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">enable_all_warnings</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_warning_names</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">enable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Diagnostics</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Diagnostic configuration (all default to disabled)</span>
<span class="sd">    - ``warn_multiple_tokens_in_named_alternation`` - flag to enable warnings when a results</span>
<span class="sd">      name is defined on a :class:`MatchFirst` or :class:`Or` expression with one or more :class:`And` subexpressions</span>
<span class="sd">    - ``warn_ungrouped_named_tokens_in_collection`` - flag to enable warnings when a results</span>
<span class="sd">      name is defined on a containing expression with ungrouped subexpressions that also</span>
<span class="sd">      have results names</span>
<span class="sd">    - ``warn_name_set_on_empty_Forward`` - flag to enable warnings when a :class:`Forward` is defined</span>
<span class="sd">      with a results name, but has no contents defined</span>
<span class="sd">    - ``warn_on_parse_using_empty_Forward`` - flag to enable warnings when a :class:`Forward` is</span>
<span class="sd">      defined in a grammar but has never had an expression attached to it</span>
<span class="sd">    - ``warn_on_assignment_to_Forward`` - flag to enable warnings when a :class:`Forward` is defined</span>
<span class="sd">      but is overwritten by assigning using ``&#39;=&#39;`` instead of ``&#39;&lt;&lt;=&#39;`` or ``&#39;&lt;&lt;&#39;``</span>
<span class="sd">    - ``warn_on_multiple_string_args_to_oneof`` - flag to enable warnings when :class:`one_of` is</span>
<span class="sd">      incorrectly called with multiple str arguments</span>
<span class="sd">    - ``enable_debug_on_named_expressions`` - flag to auto-enable debug on all subsequent</span>
<span class="sd">      calls to :class:`ParserElement.set_name`</span>

<span class="sd">    Diagnostics are enabled/disabled by calling :class:`enable_diag` and :class:`disable_diag`.</span>
<span class="sd">    All warnings can be enabled by calling :class:`enable_all_warnings`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">warn_multiple_tokens_in_named_alternation</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">warn_ungrouped_named_tokens_in_collection</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">warn_name_set_on_empty_Forward</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">warn_on_parse_using_empty_Forward</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">warn_on_assignment_to_Forward</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">warn_on_multiple_string_args_to_oneof</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">warn_on_match_first_with_lshift_operator</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">enable_debug_on_named_expressions</span> <span class="o">=</span> <span class="mi">7</span>


<span class="k">def</span> <span class="nf">enable_diag</span><span class="p">(</span><span class="n">diag_enum</span><span class="p">:</span> <span class="n">Diagnostics</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enable a global pyparsing diagnostic flag (see :class:`Diagnostics`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__diag__</span><span class="o">.</span><span class="n">enable</span><span class="p">(</span><span class="n">diag_enum</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">disable_diag</span><span class="p">(</span><span class="n">diag_enum</span><span class="p">:</span> <span class="n">Diagnostics</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Disable a global pyparsing diagnostic flag (see :class:`Diagnostics`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__diag__</span><span class="o">.</span><span class="n">disable</span><span class="p">(</span><span class="n">diag_enum</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">enable_all_warnings</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enable all global pyparsing diagnostic warnings (see :class:`Diagnostics`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__diag__</span><span class="o">.</span><span class="n">enable_all_warnings</span><span class="p">()</span>


<span class="c1"># hide abstract class</span>
<span class="k">del</span> <span class="n">__config_flags</span>


<span class="k">def</span> <span class="nf">_should_enable_warnings</span><span class="p">(</span>
    <span class="n">cmd_line_warn_options</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">warn_env_var</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">enable</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">warn_env_var</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">warn_opt</span> <span class="ow">in</span> <span class="n">cmd_line_warn_options</span><span class="p">:</span>
        <span class="n">w_action</span><span class="p">,</span> <span class="n">w_message</span><span class="p">,</span> <span class="n">w_category</span><span class="p">,</span> <span class="n">w_module</span><span class="p">,</span> <span class="n">w_line</span> <span class="o">=</span> <span class="p">(</span><span class="n">warn_opt</span> <span class="o">+</span> <span class="s2">&quot;::::&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="s2">&quot;:&quot;</span>
        <span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">w_action</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="p">(</span><span class="n">w_message</span> <span class="ow">or</span> <span class="n">w_category</span> <span class="ow">or</span> <span class="n">w_module</span><span class="p">)</span> <span class="ow">or</span> <span class="n">w_module</span> <span class="o">==</span> <span class="s2">&quot;pyparsing&quot;</span>
        <span class="p">):</span>
            <span class="n">enable</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">w_action</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">w_module</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;pyparsing&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="n">enable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">enable</span>


<span class="k">if</span> <span class="n">_should_enable_warnings</span><span class="p">(</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">warnoptions</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;PYPARSINGENABLEALLWARNINGS&quot;</span><span class="p">)</span>
<span class="p">):</span>
    <span class="n">enable_all_warnings</span><span class="p">()</span>


<span class="c1"># build list of single arg builtins, that can be used as parse actions</span>
<span class="n">_single_arg_builtins</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">sum</span><span class="p">,</span>
    <span class="nb">len</span><span class="p">,</span>
    <span class="nb">sorted</span><span class="p">,</span>
    <span class="nb">reversed</span><span class="p">,</span>
    <span class="nb">list</span><span class="p">,</span>
    <span class="nb">tuple</span><span class="p">,</span>
    <span class="nb">set</span><span class="p">,</span>
    <span class="nb">any</span><span class="p">,</span>
    <span class="nb">all</span><span class="p">,</span>
    <span class="nb">min</span><span class="p">,</span>
    <span class="nb">max</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_generatorType</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span>
<span class="n">ParseAction</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="n">ParseResults</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span>
<span class="p">]</span>
<span class="n">ParseCondition</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Callable</span><span class="p">[[],</span> <span class="nb">bool</span><span class="p">],</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="n">ParseResults</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
<span class="p">]</span>
<span class="n">ParseFailAction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>
<span class="n">DebugStartAction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>
<span class="n">DebugSuccessAction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span>
    <span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="kc">None</span>
<span class="p">]</span>
<span class="n">DebugExceptionAction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>


<span class="n">alphas</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span>
<span class="n">identchars</span> <span class="o">=</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Latin1</span><span class="o">.</span><span class="n">identchars</span>
<span class="n">identbodychars</span> <span class="o">=</span> <span class="n">pyparsing_unicode</span><span class="o">.</span><span class="n">Latin1</span><span class="o">.</span><span class="n">identbodychars</span>
<span class="n">nums</span> <span class="o">=</span> <span class="s2">&quot;0123456789&quot;</span>
<span class="n">hexnums</span> <span class="o">=</span> <span class="n">nums</span> <span class="o">+</span> <span class="s2">&quot;ABCDEFabcdef&quot;</span>
<span class="n">alphanums</span> <span class="o">=</span> <span class="n">alphas</span> <span class="o">+</span> <span class="n">nums</span>
<span class="n">printables</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">printable</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">whitespace</span><span class="p">])</span>

<span class="n">_trim_arity_call_line</span><span class="p">:</span> <span class="n">traceback</span><span class="o">.</span><span class="n">StackSummary</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_trim_arity</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">max_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;decorator to trim function calls to match the arity of the target&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_trim_arity_call_line</span>

    <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">_single_arg_builtins</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="n">limit</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">found_arity</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">extract_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
        <span class="n">frame_summary</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">frame_summary</span><span class="p">[:</span><span class="mi">2</span><span class="p">]]</span>

    <span class="c1"># synthesize what would be returned by traceback.extract_stack at the call to</span>
    <span class="c1"># user&#39;s parse action &#39;func&#39;, so that we don&#39;t incur call penalty at parse time</span>

    <span class="c1"># fmt: off</span>
    <span class="n">LINE_DIFF</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="c1"># IF ANY CODE CHANGES, EVEN JUST COMMENTS OR BLANK LINES, BETWEEN THE NEXT LINE AND</span>
    <span class="c1"># THE CALL TO FUNC INSIDE WRAPPER, LINE_DIFF MUST BE MODIFIED!!!!</span>
    <span class="n">_trim_arity_call_line</span> <span class="o">=</span> <span class="p">(</span><span class="n">_trim_arity_call_line</span> <span class="ow">or</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pa_call_line_synth</span> <span class="o">=</span> <span class="p">(</span><span class="n">_trim_arity_call_line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_trim_arity_call_line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">LINE_DIFF</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">found_arity</span><span class="p">,</span> <span class="n">limit</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">limit</span><span class="p">:])</span>
                <span class="n">found_arity</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">te</span><span class="p">:</span>
                <span class="c1"># re-raise TypeErrors if they did not come from our arity testing</span>
                <span class="k">if</span> <span class="n">found_arity</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tb</span> <span class="o">=</span> <span class="n">te</span><span class="o">.</span><span class="n">__traceback__</span>
                    <span class="n">trim_arity_type_error</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">extract_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">pa_call_line_synth</span>
                    <span class="p">)</span>
                    <span class="k">del</span> <span class="n">tb</span>

                    <span class="k">if</span> <span class="n">trim_arity_type_error</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">limit</span> <span class="o">&lt;</span> <span class="n">max_limit</span><span class="p">:</span>
                            <span class="n">limit</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">continue</span>

                    <span class="k">raise</span>
    <span class="c1"># fmt: on</span>

    <span class="c1"># copy func name to wrapper for sensible debug output</span>
    <span class="c1"># (can&#39;t use functools.wraps, since that messes with function signature)</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__class__&quot;</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func_name</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span> <span class="nf">condition_as_parse_action</span><span class="p">(</span>
    <span class="n">fn</span><span class="p">:</span> <span class="n">ParseCondition</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fatal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParseAction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to convert a simple predicate function that returns ``True`` or ``False``</span>
<span class="sd">    into a parse action. Can be used in places when a parse action is required</span>
<span class="sd">    and :class:`ParserElement.add_condition` cannot be used (such as when adding a condition</span>
<span class="sd">    to an operator level in :class:`infix_notation`).</span>

<span class="sd">    Optional keyword arguments:</span>

<span class="sd">    - ``message`` - define a custom message to be used in the raised exception</span>
<span class="sd">    - ``fatal`` - if True, will raise :class:`ParseFatalException` to stop parsing immediately;</span>
<span class="sd">      otherwise will raise :class:`ParseException`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="n">message</span> <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;failed user-defined condition&quot;</span>
    <span class="n">exc_type</span> <span class="o">=</span> <span class="n">ParseFatalException</span> <span class="k">if</span> <span class="n">fatal</span> <span class="k">else</span> <span class="n">ParseException</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">_trim_arity</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">exc_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pa</span>


<span class="k">def</span> <span class="nf">_default_start_debug_action</span><span class="p">(</span>
    <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">,</span> <span class="n">cache_hit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">):</span>
    <span class="n">cache_hit_str</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">cache_hit</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">Match </span><span class="si">{}</span><span class="s2"> at loc </span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">  </span><span class="si">{}</span><span class="se">\n</span><span class="s2">  </span><span class="si">{}</span><span class="s2">^&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">cache_hit_str</span><span class="p">,</span>
                <span class="n">expr</span><span class="p">,</span>
                <span class="n">loc</span><span class="p">,</span>
                <span class="n">lineno</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">),</span>
                <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">),</span>
                <span class="n">line</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">),</span>
                <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_default_success_debug_action</span><span class="p">(</span>
    <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">startloc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">endloc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">,</span>
    <span class="n">toks</span><span class="p">:</span> <span class="n">ParseResults</span><span class="p">,</span>
    <span class="n">cache_hit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">cache_hit_str</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">cache_hit</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">Matched </span><span class="si">{}</span><span class="s2"> -&gt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cache_hit_str</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">toks</span><span class="o">.</span><span class="n">as_list</span><span class="p">()))</span>


<span class="k">def</span> <span class="nf">_default_exception_debug_action</span><span class="p">(</span>
    <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">,</span>
    <span class="n">exc</span><span class="p">:</span> <span class="ne">Exception</span><span class="p">,</span>
    <span class="n">cache_hit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">cache_hit_str</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span> <span class="k">if</span> <span class="n">cache_hit</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">Match </span><span class="si">{}</span><span class="s2"> failed, </span><span class="si">{}</span><span class="s2"> raised: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">cache_hit_str</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">exc</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">null_debug_action</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&#39;Do-nothing&#39; debug action, to suppress debugging output during parsing.&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">ParserElement</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base level parser element class.&quot;&quot;&quot;</span>

    <span class="n">DEFAULT_WHITE_CHARS</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\n\t\r</span><span class="s2">&quot;</span>
    <span class="n">verbose_stacktrace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_literalStringClass</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">set_default_whitespace_chars</span><span class="p">(</span><span class="n">chars</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides the default whitespace chars</span>

<span class="sd">        Example::</span>

<span class="sd">            # default whitespace chars are space, &lt;TAB&gt; and newline</span>
<span class="sd">            Word(alphas)[1, ...].parse_string(&quot;abc def\nghi jkl&quot;)  # -&gt; [&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;, &#39;jkl&#39;]</span>

<span class="sd">            # change to just treat newline as significant</span>
<span class="sd">            ParserElement.set_default_whitespace_chars(&quot; \t&quot;)</span>
<span class="sd">            Word(alphas)[1, ...].parse_string(&quot;abc def\nghi jkl&quot;)  # -&gt; [&#39;abc&#39;, &#39;def&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span> <span class="o">=</span> <span class="n">chars</span>

        <span class="c1"># update whitespace all parse expressions defined in this module</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">_builtin_exprs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span><span class="p">:</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">inline_literals_using</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set class to be used for inclusion of string literals into a parser.</span>

<span class="sd">        Example::</span>

<span class="sd">            # default literal class used is Literal</span>
<span class="sd">            integer = Word(nums)</span>
<span class="sd">            date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>

<span class="sd">            date_str.parse_string(&quot;1999/12/31&quot;)  # -&gt; [&#39;1999&#39;, &#39;/&#39;, &#39;12&#39;, &#39;/&#39;, &#39;31&#39;]</span>


<span class="sd">            # change to Suppress</span>
<span class="sd">            ParserElement.inline_literals_using(Suppress)</span>
<span class="sd">            date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>

<span class="sd">            date_str.parse_string(&quot;1999/12/31&quot;)  # -&gt; [&#39;1999&#39;, &#39;12&#39;, &#39;31&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span> <span class="o">=</span> <span class="bp">cls</span>

    <span class="k">class</span> <span class="nc">DebugActions</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
        <span class="n">debug_try</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">DebugStartAction</span><span class="p">]</span>
        <span class="n">debug_match</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">DebugSuccessAction</span><span class="p">]</span>
        <span class="n">debug_fail</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">DebugExceptionAction</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">savelist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ParseAction</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">ParseFailAction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">customName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_defaultName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="n">savelist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># used when checking for left-recursion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ParserElement&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># optimize exception handling for subclasses that don&#39;t advance parse index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># mark results names as modal (report only last) or cumulative (list all)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># custom debug actions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DebugActions</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># avoid redundant calls to preParse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Diagnostics</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">suppress_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">warning_type</span><span class="p">:</span> <span class="n">Diagnostics</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Suppress warnings emitted for a particular diagnostic on this expression.</span>

<span class="sd">        Example::</span>

<span class="sd">            base = pp.Forward()</span>
<span class="sd">            base.suppress_warning(Diagnostics.warn_on_parse_using_empty_Forward)</span>

<span class="sd">            # statement would normally raise a warning, but is now suppressed</span>
<span class="sd">            print(base.parseString(&quot;x&quot;))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warning_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this :class:`ParserElement`.  Useful for defining</span>
<span class="sd">        different parse actions for the same parsing pattern, using copies of</span>
<span class="sd">        the original parse element.</span>

<span class="sd">        Example::</span>

<span class="sd">            integer = Word(nums).set_parse_action(lambda toks: int(toks[0]))</span>
<span class="sd">            integerK = integer.copy().add_parse_action(lambda toks: toks[0] * 1024) + Suppress(&quot;K&quot;)</span>
<span class="sd">            integerM = integer.copy().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress(&quot;M&quot;)</span>

<span class="sd">            print((integerK | integerM | integer)[1, ...].parse_string(&quot;5K 100 640K 256M&quot;))</span>

<span class="sd">        prints::</span>

<span class="sd">            [5120, 100, 655360, 268435456]</span>

<span class="sd">        Equivalent form of ``expr.copy()`` is just ``expr()``::</span>

<span class="sd">            integerM = integer().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress(&quot;M&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">cpy</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">[:]</span>
        <span class="n">cpy</span><span class="o">.</span><span class="n">ignoreExprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span><span class="p">:</span>
            <span class="n">cpy</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cpy</span>

    <span class="k">def</span> <span class="nf">set_results_name</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">list_all_matches</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define name for referencing matching tokens as a nested attribute</span>
<span class="sd">        of the returned parse results.</span>

<span class="sd">        Normally, results names are assigned as you would assign keys in a dict:</span>
<span class="sd">        any existing value is overwritten by later values. If it is necessary to</span>
<span class="sd">        keep all values captured for a particular results name, call ``set_results_name``</span>
<span class="sd">        with ``list_all_matches`` = True.</span>

<span class="sd">        NOTE: ``set_results_name`` returns a *copy* of the original :class:`ParserElement` object;</span>
<span class="sd">        this is so that the client can define a basic element, such as an</span>
<span class="sd">        integer, and reference it in multiple places with different names.</span>

<span class="sd">        You can also set results names using the abbreviated syntax,</span>
<span class="sd">        ``expr(&quot;name&quot;)`` in place of ``expr.set_results_name(&quot;name&quot;)``</span>
<span class="sd">        - see :class:`__call__`. If ``list_all_matches`` is required, use</span>
<span class="sd">        ``expr(&quot;name*&quot;)``.</span>

<span class="sd">        Example::</span>

<span class="sd">            date_str = (integer.set_results_name(&quot;year&quot;) + &#39;/&#39;</span>
<span class="sd">                        + integer.set_results_name(&quot;month&quot;) + &#39;/&#39;</span>
<span class="sd">                        + integer.set_results_name(&quot;day&quot;))</span>

<span class="sd">            # equivalent form:</span>
<span class="sd">            date_str = integer(&quot;year&quot;) + &#39;/&#39; + integer(&quot;month&quot;) + &#39;/&#39; + integer(&quot;day&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">listAllMatches</span> <span class="o">=</span> <span class="n">listAllMatches</span> <span class="ow">or</span> <span class="n">list_all_matches</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">newself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">listAllMatches</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">newself</span><span class="o">.</span><span class="n">resultsName</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">newself</span><span class="o">.</span><span class="n">modalResults</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">listAllMatches</span>
        <span class="k">return</span> <span class="n">newself</span>

    <span class="k">def</span> <span class="nf">set_break</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">break_flag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to invoke the Python pdb debugger when this element is</span>
<span class="sd">        about to be parsed. Set ``break_flag`` to ``True`` to enable, ``False`` to</span>
<span class="sd">        disable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">break_flag</span><span class="p">:</span>
            <span class="n">_parseMethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span>

            <span class="k">def</span> <span class="nf">breaker</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">pdb</span>

                <span class="c1"># this call to pdb.set_trace() is intentional, not a checkin error</span>
                <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">_parseMethod</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="p">)</span>

            <span class="n">breaker</span><span class="o">.</span><span class="n">_originalParseMethod</span> <span class="o">=</span> <span class="n">_parseMethod</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="n">breaker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">,</span> <span class="s2">&quot;_originalParseMethod&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="o">.</span><span class="n">_originalParseMethod</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_parse_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fns</span><span class="p">:</span> <span class="n">ParseAction</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define one or more actions to perform when successfully matching parse element definition.</span>

<span class="sd">        Parse actions can be called to perform data conversions, do extra validation,</span>
<span class="sd">        update external data structures, or enhance or replace the parsed tokens.</span>
<span class="sd">        Each parse action ``fn`` is a callable method with 0-3 arguments, called as</span>
<span class="sd">        ``fn(s, loc, toks)`` , ``fn(loc, toks)`` , ``fn(toks)`` , or just ``fn()`` , where:</span>

<span class="sd">        - s   = the original string being parsed (see note below)</span>
<span class="sd">        - loc = the location of the matching substring</span>
<span class="sd">        - toks = a list of the matched tokens, packaged as a :class:`ParseResults` object</span>

<span class="sd">        The parsed tokens are passed to the parse action as ParseResults. They can be</span>
<span class="sd">        modified in place using list-style append, extend, and pop operations to update</span>
<span class="sd">        the parsed list elements; and with dictionary-style item set and del operations</span>
<span class="sd">        to add, update, or remove any named results. If the tokens are modified in place,</span>
<span class="sd">        it is not necessary to return them with a return statement.</span>

<span class="sd">        Parse actions can also completely replace the given tokens, with another ``ParseResults``</span>
<span class="sd">        object, or with some entirely different object (common for parse actions that perform data</span>
<span class="sd">        conversions). A convenient way to build a new parse result is to define the values</span>
<span class="sd">        using a dict, and then create the return value using :class:`ParseResults.from_dict`.</span>

<span class="sd">        If None is passed as the ``fn`` parse action, all previously added parse actions for this</span>
<span class="sd">        expression are cleared.</span>

<span class="sd">        Optional keyword arguments:</span>

<span class="sd">        - call_during_try = (default= ``False``) indicate if parse action should be run during</span>
<span class="sd">          lookaheads and alternate testing. For parse actions that have side effects, it is</span>
<span class="sd">          important to only call the parse action once it is determined that it is being</span>
<span class="sd">          called as part of a successful parse. For parse actions that perform additional</span>
<span class="sd">          validation, then call_during_try should be passed as True, so that the validation</span>
<span class="sd">          code is included in the preliminary &quot;try&quot; parses.</span>

<span class="sd">        Note: the default parsing behavior is to expand tabs in the input string</span>
<span class="sd">        before starting the parsing process.  See :class:`parse_string` for more</span>
<span class="sd">        information on parsing strings containing ``&lt;TAB&gt;`` s, and suggested</span>
<span class="sd">        methods to maintain a consistent view of the parsed string, the parse</span>
<span class="sd">        location, and line and column positions within the parsed string.</span>

<span class="sd">        Example::</span>

<span class="sd">            # parse dates in the form YYYY/MM/DD</span>

<span class="sd">            # use parse action to convert toks from str to int at parse time</span>
<span class="sd">            def convert_to_int(toks):</span>
<span class="sd">                return int(toks[0])</span>

<span class="sd">            # use a parse action to verify that the date is a valid date</span>
<span class="sd">            def is_valid_date(instring, loc, toks):</span>
<span class="sd">                from datetime import date</span>
<span class="sd">                year, month, day = toks[::2]</span>
<span class="sd">                try:</span>
<span class="sd">                    date(year, month, day)</span>
<span class="sd">                except ValueError:</span>
<span class="sd">                    raise ParseException(instring, loc, &quot;invalid date given&quot;)</span>

<span class="sd">            integer = Word(nums)</span>
<span class="sd">            date_str = integer + &#39;/&#39; + integer + &#39;/&#39; + integer</span>

<span class="sd">            # add parse actions</span>
<span class="sd">            integer.set_parse_action(convert_to_int)</span>
<span class="sd">            date_str.set_parse_action(is_valid_date)</span>

<span class="sd">            # note that integer fields are now ints, not strings</span>
<span class="sd">            date_str.run_tests(&#39;&#39;&#39;</span>
<span class="sd">                # successful parse - note that integer fields were converted to ints</span>
<span class="sd">                1999/12/31</span>

<span class="sd">                # fail - invalid date</span>
<span class="sd">                1999/13/31</span>
<span class="sd">                &#39;&#39;&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">fns</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="kc">None</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;parse actions must be callable&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="p">[</span><span class="n">_trim_arity</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="s2">&quot;call_during_try&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_parse_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fns</span><span class="p">:</span> <span class="n">ParseAction</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add one or more parse actions to expression&#39;s list of parse actions. See :class:`set_parse_action`.</span>

<span class="sd">        See examples in :class:`copy`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_trim_arity</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;call_during_try&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fns</span><span class="p">:</span> <span class="n">ParseCondition</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a boolean predicate function to expression&#39;s list of parse actions. See</span>
<span class="sd">        :class:`set_parse_action` for function call signatures. Unlike ``set_parse_action``,</span>
<span class="sd">        functions passed to ``add_condition`` need to return boolean success/fail of the condition.</span>

<span class="sd">        Optional keyword arguments:</span>

<span class="sd">        - message = define a custom message to be used in the raised exception</span>
<span class="sd">        - fatal = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise</span>
<span class="sd">          ParseException</span>
<span class="sd">        - call_during_try = boolean to indicate if this method should be called during internal tryParse calls,</span>
<span class="sd">          default=False</span>

<span class="sd">        Example::</span>

<span class="sd">            integer = Word(nums).set_parse_action(lambda toks: int(toks[0]))</span>
<span class="sd">            year_int = integer.copy()</span>
<span class="sd">            year_int.add_condition(lambda toks: toks[0] &gt;= 2000, message=&quot;Only support years 2000 and later&quot;)</span>
<span class="sd">            date_str = year_int + &#39;/&#39; + integer + &#39;/&#39; + integer</span>

<span class="sd">            result = date_str.parse_string(&quot;1999/12/31&quot;)  # -&gt; Exception: Only support years 2000 and later (at char 0),</span>
<span class="sd">                                                                         (line:1, col:1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">condition_as_parse_action</span><span class="p">(</span>
                    <span class="n">fn</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">),</span> <span class="n">fatal</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fatal&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;call_during_try&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_fail_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">ParseFailAction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define action to perform if parsing fails at this expression.</span>
<span class="sd">        Fail acton fn is a callable function that takes the arguments</span>
<span class="sd">        ``fn(s, loc, expr, err)`` where:</span>

<span class="sd">        - s = string being parsed</span>
<span class="sd">        - loc = location where expression match was attempted and failed</span>
<span class="sd">        - expr = the parse expression that failed</span>
<span class="sd">        - err = the exception thrown</span>

<span class="sd">        The function returns no value.  It may throw :class:`ParseFatalException`</span>
<span class="sd">        if it is desired to stop parsing immediately.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_skipIgnorables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="n">exprsFound</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">exprsFound</span><span class="p">:</span>
            <span class="n">exprsFound</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">loc</span><span class="p">,</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                        <span class="n">exprsFound</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">preParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipIgnorables</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span><span class="p">:</span>
            <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
            <span class="n">white_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span>
            <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">white_chars</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tokenlist</span>

    <span class="c1"># @profile</span>
    <span class="k">def</span> <span class="nf">_parseNoCache</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">]:</span>
        <span class="n">TRY</span><span class="p">,</span> <span class="n">MATCH</span><span class="p">,</span> <span class="n">FAIL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
        <span class="n">debugging</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span>  <span class="c1"># and doActions)</span>
        <span class="n">len_instring</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debugging</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">:</span>
            <span class="c1"># print(&quot;Match {} at loc {}({}, {})&quot;.format(self, loc, lineno(loc, instring), col(loc, instring)))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">callPreParse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span><span class="p">:</span>
                    <span class="n">pre_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pre_loc</span> <span class="o">=</span> <span class="n">loc</span>
                <span class="n">tokens_start</span> <span class="o">=</span> <span class="n">pre_loc</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_try</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokens_start</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="ow">or</span> <span class="n">pre_loc</span> <span class="o">&gt;=</span> <span class="n">len_instring</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">pre_loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">len_instring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">pre_loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c1"># print(&quot;Exception raised:&quot;, err)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_fail</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_fail</span><span class="p">(</span>
                        <span class="n">instring</span><span class="p">,</span> <span class="n">tokens_start</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="kc">False</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokens_start</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
                <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callPreParse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span><span class="p">:</span>
                <span class="n">pre_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pre_loc</span> <span class="o">=</span> <span class="n">loc</span>
            <span class="n">tokens_start</span> <span class="o">=</span> <span class="n">pre_loc</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="ow">or</span> <span class="n">pre_loc</span> <span class="o">&gt;=</span> <span class="n">len_instring</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">pre_loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">len_instring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">pre_loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>

        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)</span>

        <span class="n">ret_tokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span>
            <span class="n">tokens</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span> <span class="n">asList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span><span class="p">,</span> <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="ow">and</span> <span class="p">(</span><span class="n">doActions</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debugging</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">tokens</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokens_start</span><span class="p">,</span> <span class="n">ret_tokens</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">parse_action_exc</span><span class="p">:</span>
                            <span class="n">exc</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="s2">&quot;exception raised in parse action&quot;</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="n">exc</span> <span class="kn">from</span> <span class="nn">parse_action_exc</span>

                        <span class="k">if</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ret_tokens</span><span class="p">:</span>
                            <span class="n">ret_tokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span>
                                <span class="n">tokens</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span>
                                <span class="n">asList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span>
                                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="p">(</span><span class="n">ParseResults</span><span class="p">,</span> <span class="nb">list</span><span class="p">)),</span>
                                <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span><span class="p">,</span>
                            <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="c1"># print &quot;Exception raised in user parse action:&quot;, err</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_fail</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_fail</span><span class="p">(</span>
                            <span class="n">instring</span><span class="p">,</span> <span class="n">tokens_start</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="kc">False</span>
                        <span class="p">)</span>
                    <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">tokens</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tokens_start</span><span class="p">,</span> <span class="n">ret_tokens</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">parse_action_exc</span><span class="p">:</span>
                        <span class="n">exc</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="s2">&quot;exception raised in parse action&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">exc</span> <span class="kn">from</span> <span class="nn">parse_action_exc</span>

                    <span class="k">if</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ret_tokens</span><span class="p">:</span>
                        <span class="n">ret_tokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span>
                            <span class="n">tokens</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span>
                            <span class="n">asList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span>
                            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="p">(</span><span class="n">ParseResults</span><span class="p">,</span> <span class="nb">list</span><span class="p">)),</span>
                            <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span><span class="p">,</span>
                        <span class="p">)</span>
        <span class="k">if</span> <span class="n">debugging</span><span class="p">:</span>
            <span class="c1"># print(&quot;Matched&quot;, self, &quot;-&gt;&quot;, ret_tokens.as_list())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_match</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_match</span><span class="p">(</span>
                    <span class="n">instring</span><span class="p">,</span> <span class="n">tokens_start</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ret_tokens</span><span class="p">,</span> <span class="kc">False</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret_tokens</span>

    <span class="k">def</span> <span class="nf">try_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">raise_fatal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">ParseFatalException</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">raise_fatal</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">can_parse_next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">try_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># cache for left-recursion in Forward references</span>
    <span class="n">recursion_lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
    <span class="n">recursion_memos</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span>
        <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;Forward&quot;</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParseResults</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">]]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># argument cache for optimizing repeated calls when backtracking through recursive expressions</span>
    <span class="n">packrat_cache</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">{}</span>
    <span class="p">)</span>  <span class="c1"># this is set later by enabled_packrat(); this is here so that reset_cache() doesn&#39;t fail</span>
    <span class="n">packrat_cache_lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
    <span class="n">packrat_cache_stats</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c1"># this method gets repeatedly called during backtracking with the same arguments -</span>
    <span class="c1"># we can cache these arguments and save ourselves the trouble of re-parsing the contained expression</span>
    <span class="k">def</span> <span class="nf">_parseCache</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">]:</span>
        <span class="n">HIT</span><span class="p">,</span> <span class="n">MISS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">TRY</span><span class="p">,</span> <span class="n">MATCH</span><span class="p">,</span> <span class="n">FAIL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
        <span class="n">lookup</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">callPreParse</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_lock</span><span class="p">:</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">cache</span><span class="o">.</span><span class="n">not_in_cache</span><span class="p">:</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_stats</span><span class="p">[</span><span class="n">MISS</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parseNoCache</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
                    <span class="c1"># cache a copy of the exception, without the traceback</span>
                    <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">*</span><span class="n">pe</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">lookup</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">loc</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_stats</span><span class="p">[</span><span class="n">HIT</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_try</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_try</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">cache_hit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_fail</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_fail</span><span class="p">(</span>
                                <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">cache_hit</span><span class="o">=</span><span class="kc">True</span>
                            <span class="p">)</span>
                        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                            <span class="k">pass</span>
                    <span class="k">raise</span> <span class="n">value</span>

                <span class="n">loc_</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">endloc</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_match</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="o">.</span><span class="n">debug_match</span><span class="p">(</span>
                            <span class="n">instring</span><span class="p">,</span> <span class="n">loc_</span><span class="p">,</span> <span class="n">endloc</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">cache_hit</span><span class="o">=</span><span class="kc">True</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="k">pass</span>

                <span class="k">return</span> <span class="n">loc_</span><span class="p">,</span> <span class="n">result</span>

    <span class="n">_parse</span> <span class="o">=</span> <span class="n">_parseNoCache</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">reset_cache</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_stats</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache_stats</span>
        <span class="p">)</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">recursion_memos</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="n">_packratEnabled</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_left_recursion_enabled</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">disable_memoization</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disables active Packrat or Left Recursion parsing and their memoization</span>

<span class="sd">        This method also works if neither Packrat nor Left Recursion are enabled.</span>
<span class="sd">        This makes it safe to call before activating Packrat nor Left Recursion</span>
<span class="sd">        to clear any previous settings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">reset_cache</span><span class="p">()</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">_left_recursion_enabled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parseNoCache</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">enable_left_recursion</span><span class="p">(</span>
        <span class="n">cache_size_limit</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enables &quot;bounded recursion&quot; parsing, which allows for both direct and indirect</span>
<span class="sd">        left-recursion. During parsing, left-recursive :class:`Forward` elements are</span>
<span class="sd">        repeatedly matched with a fixed recursion depth that is gradually increased</span>
<span class="sd">        until finding the longest match.</span>

<span class="sd">        Example::</span>

<span class="sd">            import pyparsing as pp</span>
<span class="sd">            pp.ParserElement.enable_left_recursion()</span>

<span class="sd">            E = pp.Forward(&quot;E&quot;)</span>
<span class="sd">            num = pp.Word(pp.nums)</span>
<span class="sd">            # match `num`, or `num &#39;+&#39; num`, or `num &#39;+&#39; num &#39;+&#39; num`, ...</span>
<span class="sd">            E &lt;&lt;= E + &#39;+&#39; - num | num</span>

<span class="sd">            print(E.parse_string(&quot;1+2+3&quot;))</span>

<span class="sd">        Recursion search naturally memoizes matches of ``Forward`` elements and may</span>
<span class="sd">        thus skip reevaluation of parse actions during backtracking. This may break</span>
<span class="sd">        programs with parse actions which rely on strict ordering of side-effects.</span>

<span class="sd">        Parameters:</span>

<span class="sd">        - cache_size_limit - (default=``None``) - memoize at most this many</span>
<span class="sd">          ``Forward`` elements during matching; if ``None`` (the default),</span>
<span class="sd">          memoize all ``Forward`` elements.</span>

<span class="sd">        Bounded Recursion parsing works similar but not identical to Packrat parsing,</span>
<span class="sd">        thus the two cannot be used together. Use ``force=True`` to disable any</span>
<span class="sd">        previous, conflicting settings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">disable_memoization</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Packrat and Bounded Recursion are not compatible&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cache_size_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">recursion_memos</span> <span class="o">=</span> <span class="n">_UnboundedMemo</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">cache_size_limit</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">recursion_memos</span> <span class="o">=</span> <span class="n">_LRUMemo</span><span class="p">(</span><span class="n">capacity</span><span class="o">=</span><span class="n">cache_size_limit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Memo size of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cache_size_limit</span><span class="p">)</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">_left_recursion_enabled</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">enable_packrat</span><span class="p">(</span><span class="n">cache_size_limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enables &quot;packrat&quot; parsing, which adds memoizing to the parsing logic.</span>
<span class="sd">        Repeated parse attempts at the same string location (which happens</span>
<span class="sd">        often in many complex grammars) can immediately return a cached value,</span>
<span class="sd">        instead of re-executing parsing/validating code.  Memoizing is done of</span>
<span class="sd">        both valid results and parsing exceptions.</span>

<span class="sd">        Parameters:</span>

<span class="sd">        - cache_size_limit - (default= ``128``) - if an integer value is provided</span>
<span class="sd">          will limit the size of the packrat cache; if None is passed, then</span>
<span class="sd">          the cache size will be unbounded; if 0 is passed, the cache will</span>
<span class="sd">          be effectively disabled.</span>

<span class="sd">        This speedup may break existing programs that use parse actions that</span>
<span class="sd">        have side-effects.  For this reason, packrat parsing is disabled when</span>
<span class="sd">        you first import pyparsing.  To activate the packrat feature, your</span>
<span class="sd">        program must call the class method :class:`ParserElement.enable_packrat`.</span>
<span class="sd">        For best results, call ``enable_packrat()`` immediately after</span>
<span class="sd">        importing pyparsing.</span>

<span class="sd">        Example::</span>

<span class="sd">            import pyparsing</span>
<span class="sd">            pyparsing.ParserElement.enable_packrat()</span>

<span class="sd">        Packrat parsing works similar but not identical to Bounded Recursion parsing,</span>
<span class="sd">        thus the two cannot be used together. Use ``force=True`` to disable any</span>
<span class="sd">        previous, conflicting settings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">disable_memoization</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_left_recursion_enabled</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Packrat and Bounded Recursion are not compatible&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">cache_size_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache</span> <span class="o">=</span> <span class="n">_UnboundedCache</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">packrat_cache</span> <span class="o">=</span> <span class="n">_FifoCache</span><span class="p">(</span><span class="n">cache_size_limit</span><span class="p">)</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parseCache</span>

    <span class="k">def</span> <span class="nf">parse_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">parse_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">parseAll</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParseResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse a string with respect to the parser definition. This function is intended as the primary interface to the</span>
<span class="sd">        client code.</span>

<span class="sd">        :param instring: The input string to be parsed.</span>
<span class="sd">        :param parse_all: If set, the entire input string must match the grammar.</span>
<span class="sd">        :param parseAll: retained for pre-PEP8 compatibility, will be removed in a future release.</span>
<span class="sd">        :raises ParseException: Raised if ``parse_all`` is set and the input string does not match the whole grammar.</span>
<span class="sd">        :returns: the parsed data as a :class:`ParseResults` object, which may be accessed as a `list`, a `dict`, or</span>
<span class="sd">          an object with attributes if the given parser includes results names.</span>

<span class="sd">        If the input string is required to match the entire grammar, ``parse_all`` flag must be set to ``True``. This</span>
<span class="sd">        is also equivalent to ending the grammar with :class:`StringEnd`().</span>

<span class="sd">        To report proper column numbers, ``parse_string`` operates on a copy of the input string where all tabs are</span>
<span class="sd">        converted to spaces (8 spaces per tab, as per the default in ``string.expandtabs``). If the input string</span>
<span class="sd">        contains tabs and the grammar uses parse actions that use the ``loc`` argument to index into the string</span>
<span class="sd">        being parsed, one can ensure a consistent view of the input string by doing one of the following:</span>

<span class="sd">        - calling ``parse_with_tabs`` on your grammar before calling ``parse_string`` (see :class:`parse_with_tabs`),</span>
<span class="sd">        - define your parse action using the full ``(s,loc,toks)`` signature, and reference the input string using the</span>
<span class="sd">          parse action&#39;s ``s`` argument, or</span>
<span class="sd">        - explicitly expand the tabs in your input string before calling ``parse_string``.</span>

<span class="sd">        Examples:</span>

<span class="sd">        By default, partial matches are OK.</span>

<span class="sd">        &gt;&gt;&gt; res = Word(&#39;a&#39;).parse_string(&#39;aaaaabaaa&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(res)</span>
<span class="sd">        [&#39;aaaaa&#39;]</span>

<span class="sd">        The parsing behavior varies by the inheriting class of this abstract class. Please refer to the children</span>
<span class="sd">        directly to see more examples.</span>

<span class="sd">        It raises an exception if parse_all flag is set and instring does not match the whole grammar.</span>

<span class="sd">        &gt;&gt;&gt; res = Word(&#39;a&#39;).parse_string(&#39;aaaaabaaa&#39;, parse_all=True)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        pyparsing.ParseException: Expected end of text, found &#39;b&#39;  (at char 5), (line:1, col:6)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parseAll</span> <span class="o">=</span> <span class="n">parse_all</span> <span class="ow">or</span> <span class="n">parseAll</span>

        <span class="n">ParserElement</span><span class="o">.</span><span class="n">reset_cache</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span><span class="p">:</span>
            <span class="n">instring</span> <span class="o">=</span> <span class="n">instring</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parseAll</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="n">se</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span> <span class="o">+</span> <span class="n">StringEnd</span><span class="p">()</span>
                <span class="n">se</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clearing out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">scan_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">max_matches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_MAX_INT</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">maxMatches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_MAX_INT</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ParseResults</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scan the input string for expression matches.  Each match will return the</span>
<span class="sd">        matching tokens, start location, and end location.  May be called with optional</span>
<span class="sd">        ``max_matches`` argument, to clip scanning after &#39;n&#39; matches are found.  If</span>
<span class="sd">        ``overlap`` is specified, then overlapping matches will be reported.</span>

<span class="sd">        Note that the start and end locations are reported relative to the string</span>
<span class="sd">        being parsed.  See :class:`parse_string` for more information on parsing</span>
<span class="sd">        strings with embedded tabs.</span>

<span class="sd">        Example::</span>

<span class="sd">            source = &quot;sldjf123lsdjjkf345sldkjf879lkjsfd987&quot;</span>
<span class="sd">            print(source)</span>
<span class="sd">            for tokens, start, end in Word(alphas).scan_string(source):</span>
<span class="sd">                print(&#39; &#39;*start + &#39;^&#39;*(end-start))</span>
<span class="sd">                print(&#39; &#39;*start + tokens[0])</span>

<span class="sd">        prints::</span>

<span class="sd">            sldjf123lsdjjkf345sldkjf879lkjsfd987</span>
<span class="sd">            ^^^^^</span>
<span class="sd">            sldjf</span>
<span class="sd">                    ^^^^^^^</span>
<span class="sd">                    lsdjjkf</span>
<span class="sd">                              ^^^^^^</span>
<span class="sd">                              sldkjf</span>
<span class="sd">                                       ^^^^^^</span>
<span class="sd">                                       lkjsfd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxMatches</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxMatches</span><span class="p">,</span> <span class="n">max_matches</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span><span class="p">:</span>
            <span class="n">instring</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">preparseFn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span>
        <span class="n">parseFn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">resetCache</span><span class="p">()</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;=</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">matches</span> <span class="o">&lt;</span> <span class="n">maxMatches</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">preparseFn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                    <span class="n">nextLoc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">parseFn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">=</span> <span class="n">preloc</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nextLoc</span> <span class="o">&gt;</span> <span class="n">loc</span><span class="p">:</span>
                        <span class="n">matches</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span>
                                <span class="p">{</span>
                                    <span class="s2">&quot;tokens&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="o">.</span><span class="n">asList</span><span class="p">(),</span>
                                    <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="n">preloc</span><span class="p">,</span>
                                    <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="n">nextLoc</span><span class="p">,</span>
                                <span class="p">}</span>
                            <span class="p">)</span>
                        <span class="k">yield</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">nextLoc</span>
                        <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
                            <span class="n">nextloc</span> <span class="o">=</span> <span class="n">preparseFn</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">nextloc</span> <span class="o">&gt;</span> <span class="n">loc</span><span class="p">:</span>
                                <span class="n">loc</span> <span class="o">=</span> <span class="n">nextLoc</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">loc</span> <span class="o">=</span> <span class="n">nextLoc</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">loc</span> <span class="o">=</span> <span class="n">preloc</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extension to :class:`scan_string`, to modify matching text with modified tokens that may</span>
<span class="sd">        be returned from a parse action.  To use ``transform_string``, define a grammar and</span>
<span class="sd">        attach a parse action to it that modifies the returned token list.</span>
<span class="sd">        Invoking ``transform_string()`` on a target string will then scan for matches,</span>
<span class="sd">        and replace the matched text patterns according to the logic in the parse</span>
<span class="sd">        action.  ``transform_string()`` returns the resulting transformed string.</span>

<span class="sd">        Example::</span>

<span class="sd">            wd = Word(alphas)</span>
<span class="sd">            wd.set_parse_action(lambda toks: toks[0].title())</span>

<span class="sd">            print(wd.transform_string(&quot;now is the winter of our discontent made glorious summer by this sun of york.&quot;))</span>

<span class="sd">        prints::</span>

<span class="sd">            Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lastE</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># force preservation of &lt;TAB&gt;s, to minimize unwanted transformation of string, and to</span>
        <span class="c1"># keep string locs straight between transform_string and scan_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_string</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">lastE</span><span class="p">:</span><span class="n">s</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                        <span class="n">out</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">lastE</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">lastE</span><span class="p">:])</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out</span> <span class="k">if</span> <span class="n">o</span><span class="p">]</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">out</span><span class="p">)])</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">search_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">max_matches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_MAX_INT</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">maxMatches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_MAX_INT</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParseResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Another extension to :class:`scan_string`, simplifying the access to the tokens found</span>
<span class="sd">        to match the given parse expression.  May be called with optional</span>
<span class="sd">        ``max_matches`` argument, to clip searching after &#39;n&#39; matches are found.</span>

<span class="sd">        Example::</span>

<span class="sd">            # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters</span>
<span class="sd">            cap_word = Word(alphas.upper(), alphas.lower())</span>

<span class="sd">            print(cap_word.search_string(&quot;More than Iron, more than Lead, more than Gold I need Electricity&quot;))</span>

<span class="sd">            # the sum() builtin can be used to merge results into a single ParseResults object</span>
<span class="sd">            print(sum(cap_word.search_string(&quot;More than Iron, more than Lead, more than Gold I need Electricity&quot;)))</span>

<span class="sd">        prints::</span>

<span class="sd">            [[&#39;More&#39;], [&#39;Iron&#39;], [&#39;Lead&#39;], [&#39;Gold&#39;], [&#39;I&#39;], [&#39;Electricity&#39;]]</span>
<span class="sd">            [&#39;More&#39;, &#39;Iron&#39;, &#39;Lead&#39;, &#39;Gold&#39;, &#39;I&#39;, &#39;Electricity&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxMatches</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxMatches</span><span class="p">,</span> <span class="n">max_matches</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ParseResults</span><span class="p">(</span>
                <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_string</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">maxMatches</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">instring</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">maxsplit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_MAX_INT</span><span class="p">,</span>
        <span class="n">include_separators</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">includeSeparators</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generator method to split a string using the given expression as a separator.</span>
<span class="sd">        May be called with optional ``maxsplit`` argument, to limit the number of splits;</span>
<span class="sd">        and the optional ``include_separators`` argument (default= ``False``), if the separating</span>
<span class="sd">        matching text should be included in the split results.</span>

<span class="sd">        Example::</span>

<span class="sd">            punc = one_of(list(&quot;.,;:/-!?&quot;))</span>
<span class="sd">            print(list(punc.split(&quot;This, this?, this sentence, is badly punctuated!&quot;)))</span>

<span class="sd">        prints::</span>

<span class="sd">            [&#39;This&#39;, &#39; this&#39;, &#39;&#39;, &#39; this sentence&#39;, &#39; is badly punctuated&#39;, &#39;&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">includeSeparators</span> <span class="o">=</span> <span class="n">includeSeparators</span> <span class="ow">or</span> <span class="n">include_separators</span>
        <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_string</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">max_matches</span><span class="o">=</span><span class="n">maxsplit</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">instring</span><span class="p">[</span><span class="n">last</span><span class="p">:</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">includeSeparators</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">yield</span> <span class="n">instring</span><span class="p">[</span><span class="n">last</span><span class="p">:]</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``+`` operator - returns :class:`And`. Adding strings to a :class:`ParserElement`</span>
<span class="sd">        converts them to :class:`Literal`s by default.</span>

<span class="sd">        Example::</span>

<span class="sd">            greet = Word(alphas) + &quot;,&quot; + Word(alphas) + &quot;!&quot;</span>
<span class="sd">            hello = &quot;Hello, World!&quot;</span>
<span class="sd">            print(hello, &quot;-&gt;&quot;, greet.parse_string(hello))</span>

<span class="sd">        prints::</span>

<span class="sd">            Hello, World! -&gt; [&#39;Hello&#39;, &#39;,&#39;, &#39;World&#39;, &#39;!&#39;]</span>

<span class="sd">        ``...`` may be used as a parse expression as a short form of :class:`SkipTo`.</span>

<span class="sd">            Literal(&#39;start&#39;) + ... + Literal(&#39;end&#39;)</span>

<span class="sd">        is equivalent to:</span>

<span class="sd">            Literal(&#39;start&#39;) + SkipTo(&#39;end&#39;)(&quot;_skipped*&quot;) + Literal(&#39;end&#39;)</span>

<span class="sd">        Note that the skipped text is returned with &#39;_skipped&#39; as a results name,</span>
<span class="sd">        and to support having multiple skips in the same parser, the value returned is</span>
<span class="sd">        a list of all skipped text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_PendingSkip</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``+`` operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SkipTo</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="s2">&quot;_skipped*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">+</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``-`` operator, returns :class:`And` with error stop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">And</span><span class="o">.</span><span class="n">_ErrorStop</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``-`` operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">-</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``*`` operator, allows use of ``expr * 3`` in place of</span>
<span class="sd">        ``expr + expr + expr``.  Expressions may also be multiplied by a 2-integer</span>
<span class="sd">        tuple, similar to ``{min, max}`` multipliers in regular expressions.  Tuples</span>
<span class="sd">        may also include ``None`` as in:</span>
<span class="sd">        - ``expr*(n, None)`` or ``expr*(n, )`` is equivalent</span>
<span class="sd">             to ``expr*n + ZeroOrMore(expr)``</span>
<span class="sd">             (read as &quot;at least n instances of ``expr``&quot;)</span>
<span class="sd">        - ``expr*(None, n)`` is equivalent to ``expr*(0, n)``</span>
<span class="sd">             (read as &quot;0 to n instances of ``expr``&quot;)</span>
<span class="sd">        - ``expr*(None, None)`` is equivalent to ``ZeroOrMore(expr)``</span>
<span class="sd">        - ``expr*(1, None)`` is equivalent to ``OneOrMore(expr)``</span>

<span class="sd">        Note that ``expr*(None, n)`` does not raise an exception if</span>
<span class="sd">        more than n exprs exist in the input stream; that is,</span>
<span class="sd">        ``expr*(None, n)`` does not enforce a maximum number of expr</span>
<span class="sd">        occurrences.  If this behavior is desired, then write</span>
<span class="sd">        ``expr*(None, n) + ~expr``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,))[:</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">minElements</span><span class="p">,</span> <span class="n">optElements</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">o</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">Ellipsis</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">other</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">minElements</span><span class="p">,</span> <span class="n">optElements</span> <span class="o">=</span> <span class="n">other</span>
                <span class="n">optElements</span> <span class="o">-=</span> <span class="n">minElements</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;cannot multiply ParserElement and (</span><span class="si">{}</span><span class="s2">) objects&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">other</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot multiply ParserElement and </span><span class="si">{}</span><span class="s2"> objects&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">minElements</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot multiply ParserElement by negative value&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optElements</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;second tuple value must be greater or equal to first tuple value&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">minElements</span> <span class="o">==</span> <span class="n">optElements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">And</span><span class="p">([])</span>

        <span class="k">if</span> <span class="n">optElements</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">makeOptionalList</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Opt</span><span class="p">(</span><span class="bp">self</span> <span class="o">+</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Opt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">minElements</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">minElements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">optElements</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">And</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">*</span> <span class="n">minElements</span><span class="p">)</span> <span class="o">+</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">optElements</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">optElements</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">minElements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">And</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span> <span class="o">*</span> <span class="n">minElements</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``|`` operator - returns :class:`MatchFirst`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_PendingSkip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">must_skip</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">MatchFirst</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``|`` operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">|</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``^`` operator - returns :class:`Or`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">Or</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``^`` operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">^</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``&amp;`` operator - returns :class:`Each`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">Each</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``&amp;`` operator when left operand is not a :class:`ParserElement`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot combine element of type </span><span class="si">{}</span><span class="s2"> with ParserElement&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">&amp;</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of ``~`` operator - returns :class:`NotAny`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">NotAny</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># disable __iter__ to override legacy use of sequential access to __getitem__ to</span>
    <span class="c1"># iterate over a sequence</span>
    <span class="fm">__iter__</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        use ``[]`` indexing notation as a short form for expression repetition:</span>

<span class="sd">        - ``expr[n]`` is equivalent to ``expr*n``</span>
<span class="sd">        - ``expr[m, n]`` is equivalent to ``expr*(m, n)``</span>
<span class="sd">        - ``expr[n, ...]`` or ``expr[n,]`` is equivalent</span>
<span class="sd">             to ``expr*n + ZeroOrMore(expr)``</span>
<span class="sd">             (read as &quot;at least n instances of ``expr``&quot;)</span>
<span class="sd">        - ``expr[..., n]`` is equivalent to ``expr*(0, n)``</span>
<span class="sd">             (read as &quot;0 to n instances of ``expr``&quot;)</span>
<span class="sd">        - ``expr[...]`` and ``expr[0, ...]`` are equivalent to ``ZeroOrMore(expr)``</span>
<span class="sd">        - ``expr[1, ...]`` is equivalent to ``OneOrMore(expr)``</span>

<span class="sd">        ``None`` may be used in place of ``...``.</span>

<span class="sd">        Note that ``expr[..., n]`` and ``expr[m, n]``do not raise an exception</span>
<span class="sd">        if more than ``n`` ``expr``s exist in the input stream.  If this behavior is</span>
<span class="sd">        desired, then write ``expr[..., n] + ~expr``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># convert single arg keys to tuples</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;only 1 or 2 index arguments supported (</span><span class="si">{}{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">key</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="s2">&quot;... [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># clip to 2 elements</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">*</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shortcut for :class:`set_results_name`, with ``list_all_matches=False``.</span>

<span class="sd">        If ``name`` is given with a trailing ``&#39;*&#39;`` character, then ``list_all_matches`` will be</span>
<span class="sd">        passed as ``True``.</span>

<span class="sd">        If ``name` is omitted, same as calling :class:`copy`.</span>

<span class="sd">        Example::</span>

<span class="sd">            # these are equivalent</span>
<span class="sd">            userdata = Word(alphas).set_results_name(&quot;name&quot;) + Word(nums + &quot;-&quot;).set_results_name(&quot;socsecno&quot;)</span>
<span class="sd">            userdata = Word(alphas)(&quot;name&quot;) + Word(nums + &quot;-&quot;)(&quot;socsecno&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">suppress</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Suppresses the output of this :class:`ParserElement`; useful to keep punctuation from</span>
<span class="sd">        cluttering up returned output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Suppress</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ignore_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enables the skipping of whitespace before matching the characters in the</span>
<span class="sd">        :class:`ParserElement`&#39;s defined pattern.</span>

<span class="sd">        :param recursive: If ``True`` (the default), also enable whitespace skipping in child elements (if any)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">leave_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Disables the skipping of whitespace before matching the characters in the</span>
<span class="sd">        :class:`ParserElement`&#39;s defined pattern.  This is normally only used internally by</span>
<span class="sd">        the pyparsing module, but may be needed in some whitespace-sensitive grammars.</span>

<span class="sd">        :param recursive: If true (the default), also disable whitespace skipping in child elements (if any)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_whitespace_chars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="n">copy_defaults</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides the default whitespace chars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span> <span class="o">=</span> <span class="n">copy_defaults</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parse_with_tabs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides default behavior to expand ``&lt;TAB&gt;`` s to spaces before parsing the input string.</span>
<span class="sd">        Must be called before ``parse_string`` when the input grammar contains elements that</span>
<span class="sd">        match ``&lt;TAB&gt;`` characters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define expression to be ignored (e.g., comments) while doing pattern</span>
<span class="sd">        matching; may be called repeatedly, to define multiple comment or other</span>
<span class="sd">        ignorable patterns.</span>

<span class="sd">        Example::</span>

<span class="sd">            patt = Word(alphas)[1, ...]</span>
<span class="sd">            patt.parse_string(&#39;ablaj /* comment */ lskjd&#39;)</span>
<span class="sd">            # -&gt; [&#39;ablaj&#39;]</span>

<span class="sd">            patt.ignore(c_style_comment)</span>
<span class="sd">            patt.parse_string(&#39;ablaj /* comment */ lskjd&#39;)</span>
<span class="sd">            # -&gt; [&#39;ablaj&#39;, &#39;lskjd&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">typing</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Suppress</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Suppress</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_debug_actions</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_action</span><span class="p">:</span> <span class="n">DebugStartAction</span><span class="p">,</span>
        <span class="n">success_action</span><span class="p">:</span> <span class="n">DebugSuccessAction</span><span class="p">,</span>
        <span class="n">exception_action</span><span class="p">:</span> <span class="n">DebugExceptionAction</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Customize display of debugging messages while doing pattern matching:</span>

<span class="sd">        - ``start_action`` - method to be called when an expression is about to be parsed;</span>
<span class="sd">          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, cache_hit: bool)``</span>

<span class="sd">        - ``success_action`` - method to be called when an expression has successfully parsed;</span>
<span class="sd">          should have the signature ``fn(input_string: str, start_location: int, end_location: int, expression: ParserELement, parsed_tokens: ParseResults, cache_hit: bool)``</span>

<span class="sd">        - ``exception_action`` - method to be called when expression fails to parse;</span>
<span class="sd">          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, exception: Exception, cache_hit: bool)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DebugActions</span><span class="p">(</span>
            <span class="n">start_action</span> <span class="ow">or</span> <span class="n">_default_start_debug_action</span><span class="p">,</span>
            <span class="n">success_action</span> <span class="ow">or</span> <span class="n">_default_success_debug_action</span><span class="p">,</span>
            <span class="n">exception_action</span> <span class="ow">or</span> <span class="n">_default_exception_debug_action</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">set_debug</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enable display of debugging messages while doing pattern matching.</span>
<span class="sd">        Set ``flag`` to ``True`` to enable, ``False`` to disable.</span>

<span class="sd">        Example::</span>

<span class="sd">            wd = Word(alphas).set_name(&quot;alphaword&quot;)</span>
<span class="sd">            integer = Word(nums).set_name(&quot;numword&quot;)</span>
<span class="sd">            term = wd | integer</span>

<span class="sd">            # turn on debugging for wd</span>
<span class="sd">            wd.set_debug()</span>

<span class="sd">            term[1, ...].parse_string(&quot;abc 123 xyz 890&quot;)</span>

<span class="sd">        prints::</span>

<span class="sd">            Match alphaword at loc 0(1,1)</span>
<span class="sd">            Matched alphaword -&gt; [&#39;abc&#39;]</span>
<span class="sd">            Match alphaword at loc 3(1,4)</span>
<span class="sd">            Exception raised:Expected alphaword (at char 4), (line:1, col:5)</span>
<span class="sd">            Match alphaword at loc 7(1,8)</span>
<span class="sd">            Matched alphaword -&gt; [&#39;xyz&#39;]</span>
<span class="sd">            Match alphaword at loc 11(1,12)</span>
<span class="sd">            Exception raised:Expected alphaword (at char 12), (line:1, col:13)</span>
<span class="sd">            Match alphaword at loc 15(1,16)</span>
<span class="sd">            Exception raised:Expected alphaword (at char 15), (line:1, col:16)</span>

<span class="sd">        The output shown is that produced by the default debug actions - custom debug actions can be</span>
<span class="sd">        specified using :class:`set_debug_actions`. Prior to attempting</span>
<span class="sd">        to match the ``wd`` expression, the debugging message ``&quot;Match &lt;exprname&gt; at loc &lt;n&gt;(&lt;line&gt;,&lt;col&gt;)&quot;``</span>
<span class="sd">        is shown. Then if the parse succeeds, a ``&quot;Matched&quot;`` message is shown, or an ``&quot;Exception raised&quot;``</span>
<span class="sd">        message is shown. Also note the use of :class:`set_name` to assign a human-readable name to the expression,</span>
<span class="sd">        which makes debugging and exception messages easier to understand - for instance, the default</span>
<span class="sd">        name created for the :class:`Word` expression without calling ``set_name`` is ``&quot;W:(A-Za-z)&quot;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_debug_actions</span><span class="p">(</span>
                <span class="n">_default_start_debug_action</span><span class="p">,</span>
                <span class="n">_default_success_debug_action</span><span class="p">,</span>
                <span class="n">_default_exception_debug_action</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_defaultName</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_defaultName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generateDefaultName</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_defaultName</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Child classes must define this method, which defines how the ``default_name`` is set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">set_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define name for this expression, makes debugging and exception messages clearer.</span>
<span class="sd">        Example::</span>
<span class="sd">            Word(nums).parse_string(&quot;ABC&quot;)  # -&gt; Exception: Expected W:(0-9) (at char 0), (line:1, col:1)</span>
<span class="sd">            Word(nums).set_name(&quot;integer&quot;).parse_string(&quot;ABC&quot;)  # -&gt; Exception: Expected integer (at char 0), (line:1, col:1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">customName</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">enable_debug_on_named_expressions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_debug</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># This will use a user-defined name if available, but otherwise defaults back to the auto-generated name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">customName</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">customName</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_name</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_defaultName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="s2">&quot;ParserElement&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_checkRecursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">recurse</span><span class="p">():</span>
            <span class="n">e</span><span class="o">.</span><span class="n">_checkRecursion</span><span class="p">(</span><span class="n">subRecCheckList</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check defined expressions for valid structure, check for infinite recursive definitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkRecursion</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">parse_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_or_filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">TextIO</span><span class="p">],</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">,</span>
        <span class="n">parse_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">parseAll</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParseResults</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the parse expression on the given file or filename.</span>
<span class="sd">        If a filename is specified (instead of a file object),</span>
<span class="sd">        the entire file is opened, read, and closed before parsing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parseAll</span> <span class="o">=</span> <span class="n">parseAll</span> <span class="ow">or</span> <span class="n">parse_all</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">file_contents</span> <span class="o">=</span> <span class="n">file_or_filename</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_or_filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">file_contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="n">file_contents</span><span class="p">,</span> <span class="n">parseAll</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">parse_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">vars</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">test_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">parse_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">parseAll</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method for quick testing of a parser against a test string. Good for simple</span>
<span class="sd">        inline microtests of sub expressions while building up larger parser.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - ``test_string`` - to test against this expression for a match</span>
<span class="sd">        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests</span>

<span class="sd">        Example::</span>

<span class="sd">            expr = Word(nums)</span>
<span class="sd">            assert expr.matches(&quot;100&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parseAll</span> <span class="o">=</span> <span class="n">parseAll</span> <span class="ow">and</span> <span class="n">parse_all</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">test_string</span><span class="p">),</span> <span class="n">parse_all</span><span class="o">=</span><span class="n">parseAll</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">run_tests</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tests</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">parse_all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">comment</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ParserElement&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;#&quot;</span><span class="p">,</span>
        <span class="n">full_dump</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">print_results</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">failure_tests</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">post_parse</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">file</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">TextIO</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">with_line_numbers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">parseAll</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">fullDump</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">printResults</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">failureTests</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">postParse</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParseResults</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">]]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the parse expression on a series of test strings, showing each</span>
<span class="sd">        test, the parsed results or where the parse failed. Quick and easy way to</span>
<span class="sd">        run a parse expression against a list of sample strings.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - ``tests`` - a list of separate test strings, or a multiline string of test strings</span>
<span class="sd">        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests</span>
<span class="sd">        - ``comment`` - (default= ``&#39;#&#39;``) - expression for indicating embedded comments in the test</span>
<span class="sd">          string; pass None to disable comment filtering</span>
<span class="sd">        - ``full_dump`` - (default= ``True``) - dump results as list followed by results names in nested outline;</span>
<span class="sd">          if False, only dump nested list</span>
<span class="sd">        - ``print_results`` - (default= ``True``) prints test output to stdout</span>
<span class="sd">        - ``failure_tests`` - (default= ``False``) indicates if these tests are expected to fail parsing</span>
<span class="sd">        - ``post_parse`` - (default= ``None``) optional callback for successful parse results; called as</span>
<span class="sd">          `fn(test_string, parse_results)` and returns a string to be added to the test output</span>
<span class="sd">        - ``file`` - (default= ``None``) optional file-like object to which test output will be written;</span>
<span class="sd">          if None, will default to ``sys.stdout``</span>
<span class="sd">        - ``with_line_numbers`` - default= ``False``) show test strings with line and column numbers</span>

<span class="sd">        Returns: a (success, results) tuple, where success indicates that all tests succeeded</span>
<span class="sd">        (or failed if ``failure_tests`` is True), and the results contain a list of lines of each</span>
<span class="sd">        test&#39;s output</span>

<span class="sd">        Example::</span>

<span class="sd">            number_expr = pyparsing_common.number.copy()</span>

<span class="sd">            result = number_expr.run_tests(&#39;&#39;&#39;</span>
<span class="sd">                # unsigned integer</span>
<span class="sd">                100</span>
<span class="sd">                # negative integer</span>
<span class="sd">                -100</span>
<span class="sd">                # float with scientific notation</span>
<span class="sd">                6.02e23</span>
<span class="sd">                # integer with scientific notation</span>
<span class="sd">                1e-12</span>
<span class="sd">                &#39;&#39;&#39;)</span>
<span class="sd">            print(&quot;Success&quot; if result[0] else &quot;Failed!&quot;)</span>

<span class="sd">            result = number_expr.run_tests(&#39;&#39;&#39;</span>
<span class="sd">                # stray character</span>
<span class="sd">                100Z</span>
<span class="sd">                # missing leading digit before &#39;.&#39;</span>
<span class="sd">                -.100</span>
<span class="sd">                # too many &#39;.&#39;</span>
<span class="sd">                3.14.159</span>
<span class="sd">                &#39;&#39;&#39;, failure_tests=True)</span>
<span class="sd">            print(&quot;Success&quot; if result[0] else &quot;Failed!&quot;)</span>

<span class="sd">        prints::</span>

<span class="sd">            # unsigned integer</span>
<span class="sd">            100</span>
<span class="sd">            [100]</span>

<span class="sd">            # negative integer</span>
<span class="sd">            -100</span>
<span class="sd">            [-100]</span>

<span class="sd">            # float with scientific notation</span>
<span class="sd">            6.02e23</span>
<span class="sd">            [6.02e+23]</span>

<span class="sd">            # integer with scientific notation</span>
<span class="sd">            1e-12</span>
<span class="sd">            [1e-12]</span>

<span class="sd">            Success</span>

<span class="sd">            # stray character</span>
<span class="sd">            100Z</span>
<span class="sd">               ^</span>
<span class="sd">            FAIL: Expected end of text (at char 3), (line:1, col:4)</span>

<span class="sd">            # missing leading digit before &#39;.&#39;</span>
<span class="sd">            -.100</span>
<span class="sd">            ^</span>
<span class="sd">            FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)</span>

<span class="sd">            # too many &#39;.&#39;</span>
<span class="sd">            3.14.159</span>
<span class="sd">                ^</span>
<span class="sd">            FAIL: Expected end of text (at char 4), (line:1, col:5)</span>

<span class="sd">            Success</span>

<span class="sd">        Each test string must be on a single line. If you want to test a string that spans multiple</span>
<span class="sd">        lines, create a test like this::</span>

<span class="sd">            expr.run_tests(r&quot;this is a test\\n of strings that spans \\n 3 lines&quot;)</span>

<span class="sd">        (Note that this is a raw string literal, you must include the leading ``&#39;r&#39;``.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.testing</span> <span class="kn">import</span> <span class="n">pyparsing_test</span>

        <span class="n">parseAll</span> <span class="o">=</span> <span class="n">parseAll</span> <span class="ow">and</span> <span class="n">parse_all</span>
        <span class="n">fullDump</span> <span class="o">=</span> <span class="n">fullDump</span> <span class="ow">and</span> <span class="n">full_dump</span>
        <span class="n">printResults</span> <span class="o">=</span> <span class="n">printResults</span> <span class="ow">and</span> <span class="n">print_results</span>
        <span class="n">failureTests</span> <span class="o">=</span> <span class="n">failureTests</span> <span class="ow">or</span> <span class="n">failure_tests</span>
        <span class="n">postParse</span> <span class="o">=</span> <span class="n">postParse</span> <span class="ow">or</span> <span class="n">post_parse</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tests</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">line_strip</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span>
            <span class="n">tests</span> <span class="o">=</span> <span class="p">[</span><span class="n">line_strip</span><span class="p">(</span><span class="n">test_line</span><span class="p">)</span> <span class="k">for</span> <span class="n">test_line</span> <span class="ow">in</span> <span class="n">tests</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
        <span class="n">print_</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">write</span>

        <span class="n">result</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParseResults</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">]</span>
        <span class="n">allResults</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">NL</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\n&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">add_parse_action</span><span class="p">(</span><span class="n">replace_with</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">quoted_string</span><span class="p">)</span>
        <span class="n">BOM</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\ufeff</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">comment</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">comments</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">pyparsing_test</span><span class="o">.</span><span class="n">with_line_numbers</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">if</span> <span class="n">with_line_numbers</span> <span class="k">else</span> <span class="n">t</span>
                <span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comments</span><span class="p">)</span> <span class="k">if</span> <span class="n">comments</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">pyparsing_test</span><span class="o">.</span><span class="n">with_line_numbers</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">if</span> <span class="n">with_line_numbers</span> <span class="k">else</span> <span class="n">t</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># convert newline marks to actual newlines, and strip leading BOM if present</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">NL</span><span class="o">.</span><span class="n">transform_string</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="n">BOM</span><span class="p">))</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">parse_all</span><span class="o">=</span><span class="n">parseAll</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
                <span class="n">fatal</span> <span class="o">=</span> <span class="s2">&quot;(FATAL)&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="n">ParseFatalException</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pe</span><span class="o">.</span><span class="n">explain</span><span class="p">())</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FAIL: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pe</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_tb</span><span class="p">(</span><span class="n">pe</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">))</span>
                <span class="n">success</span> <span class="o">=</span> <span class="n">success</span> <span class="ow">and</span> <span class="n">failureTests</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">pe</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FAIL-EXCEPTION: </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_tb</span><span class="p">(</span><span class="n">exc</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">))</span>
                <span class="n">success</span> <span class="o">=</span> <span class="n">success</span> <span class="ow">and</span> <span class="n">failureTests</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">exc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">success</span> <span class="o">=</span> <span class="n">success</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">failureTests</span>
                <span class="k">if</span> <span class="n">postParse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">pp_value</span> <span class="o">=</span> <span class="n">postParse</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">pp_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pp_value</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pp_value</span><span class="o">.</span><span class="n">dump</span><span class="p">())</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">pp_value</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dump</span><span class="p">())</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">full</span><span class="o">=</span><span class="n">fullDump</span><span class="p">))</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> failed: </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">postParse</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">e</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">full</span><span class="o">=</span><span class="n">fullDump</span><span class="p">))</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">printResults</span><span class="p">:</span>
                <span class="n">print_</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>

            <span class="n">allResults</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">allResults</span>

    <span class="k">def</span> <span class="nf">create_diagram</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">output_html</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TextIO</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">vertical</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">show_results_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">show_groups</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a railroad diagram for the parser.</span>

<span class="sd">        Parameters:</span>
<span class="sd">        - output_html (str or file-like object) - output target for generated</span>
<span class="sd">          diagram HTML</span>
<span class="sd">        - vertical (int) - threshold for formatting multiple alternatives vertically</span>
<span class="sd">          instead of horizontally (default=3)</span>
<span class="sd">        - show_results_names - bool flag whether diagram should show annotations for</span>
<span class="sd">          defined results names</span>
<span class="sd">        - show_groups - bool flag whether groups should be highlighted with an unlabeled surrounding box</span>
<span class="sd">        Additional diagram-formatting keyword arguments can also be included;</span>
<span class="sd">        see railroad.Diagram class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.diagram</span> <span class="kn">import</span> <span class="n">to_railroad</span><span class="p">,</span> <span class="n">railroad_to_html</span>
        <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">ie</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;must ``pip install pyparsing[diagrams]`` to generate parser railroad diagrams&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">ie</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="n">railroad</span> <span class="o">=</span> <span class="n">to_railroad</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">vertical</span><span class="o">=</span><span class="n">vertical</span><span class="p">,</span>
            <span class="n">show_results_names</span><span class="o">=</span><span class="n">show_results_names</span><span class="p">,</span>
            <span class="n">show_groups</span><span class="o">=</span><span class="n">show_groups</span><span class="p">,</span>
            <span class="n">diagram_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_html</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_html</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">diag_file</span><span class="p">:</span>
                <span class="n">diag_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">railroad_to_html</span><span class="p">(</span><span class="n">railroad</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we were passed a file-like object, just write to it</span>
            <span class="n">output_html</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">railroad_to_html</span><span class="p">(</span><span class="n">railroad</span><span class="p">))</span>

    <span class="n">setDefaultWhitespaceChars</span> <span class="o">=</span> <span class="n">set_default_whitespace_chars</span>
    <span class="n">inlineLiteralsUsing</span> <span class="o">=</span> <span class="n">inline_literals_using</span>
    <span class="n">setResultsName</span> <span class="o">=</span> <span class="n">set_results_name</span>
    <span class="n">setBreak</span> <span class="o">=</span> <span class="n">set_break</span>
    <span class="n">setParseAction</span> <span class="o">=</span> <span class="n">set_parse_action</span>
    <span class="n">addParseAction</span> <span class="o">=</span> <span class="n">add_parse_action</span>
    <span class="n">addCondition</span> <span class="o">=</span> <span class="n">add_condition</span>
    <span class="n">setFailAction</span> <span class="o">=</span> <span class="n">set_fail_action</span>
    <span class="n">tryParse</span> <span class="o">=</span> <span class="n">try_parse</span>
    <span class="n">canParseNext</span> <span class="o">=</span> <span class="n">can_parse_next</span>
    <span class="n">resetCache</span> <span class="o">=</span> <span class="n">reset_cache</span>
    <span class="n">enableLeftRecursion</span> <span class="o">=</span> <span class="n">enable_left_recursion</span>
    <span class="n">enablePackrat</span> <span class="o">=</span> <span class="n">enable_packrat</span>
    <span class="n">parseString</span> <span class="o">=</span> <span class="n">parse_string</span>
    <span class="n">scanString</span> <span class="o">=</span> <span class="n">scan_string</span>
    <span class="n">searchString</span> <span class="o">=</span> <span class="n">search_string</span>
    <span class="n">transformString</span> <span class="o">=</span> <span class="n">transform_string</span>
    <span class="n">setWhitespaceChars</span> <span class="o">=</span> <span class="n">set_whitespace_chars</span>
    <span class="n">parseWithTabs</span> <span class="o">=</span> <span class="n">parse_with_tabs</span>
    <span class="n">setDebugActions</span> <span class="o">=</span> <span class="n">set_debug_actions</span>
    <span class="n">setDebug</span> <span class="o">=</span> <span class="n">set_debug</span>
    <span class="n">defaultName</span> <span class="o">=</span> <span class="n">default_name</span>
    <span class="n">setName</span> <span class="o">=</span> <span class="n">set_name</span>
    <span class="n">parseFile</span> <span class="o">=</span> <span class="n">parse_file</span>
    <span class="n">runTests</span> <span class="o">=</span> <span class="n">run_tests</span>
    <span class="n">ignoreWhitespace</span> <span class="o">=</span> <span class="n">ignore_whitespace</span>
    <span class="n">leaveWhitespace</span> <span class="o">=</span> <span class="n">leave_whitespace</span>


<span class="k">class</span> <span class="nc">_PendingSkip</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
    <span class="c1"># internal placeholder class to hold a place were &#39;...&#39; is added to a parser element,</span>
    <span class="c1"># once another ParserElement is added, this placeholder will be replaced with a SkipTo</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParserElement</span><span class="p">,</span> <span class="n">must_skip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anchor</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">must_skip</span> <span class="o">=</span> <span class="n">must_skip</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor</span> <span class="o">+</span> <span class="n">Empty</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;Empty&quot;</span><span class="p">,</span> <span class="s2">&quot;...&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
        <span class="n">skipper</span> <span class="o">=</span> <span class="n">SkipTo</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)(</span><span class="s2">&quot;_skipped*&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">must_skip</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">must_skip</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">_skipped</span> <span class="ow">or</span> <span class="n">t</span><span class="o">.</span><span class="n">_skipped</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_skipped&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">show_skip</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">_skipped</span><span class="o">.</span><span class="n">as_list</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]:</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_skipped&quot;</span><span class="p">)</span>
                    <span class="n">t</span><span class="p">[</span><span class="s2">&quot;_skipped&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;missing &lt;&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anchor</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span>

            <span class="k">return</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">anchor</span> <span class="o">+</span> <span class="n">skipper</span><span class="p">()</span><span class="o">.</span><span class="n">add_parse_action</span><span class="p">(</span><span class="n">must_skip</span><span class="p">)</span>
                <span class="o">|</span> <span class="n">skipper</span><span class="p">()</span><span class="o">.</span><span class="n">add_parse_action</span><span class="p">(</span><span class="n">show_skip</span><span class="p">)</span>
            <span class="p">)</span> <span class="o">+</span> <span class="n">other</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">anchor</span> <span class="o">+</span> <span class="n">skipper</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultName</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;use of `...` expression without following SkipTo target expression&quot;</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract :class:`ParserElement` subclass, for defining atomic</span>
<span class="sd">    matching patterns.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>


<span class="k">class</span> <span class="nc">Empty</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An empty token, will always match.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">NoMatch</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A token that will never match.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Unmatchable token&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Token to exactly match a specified string.</span>

<span class="sd">    Example::</span>

<span class="sd">        Literal(&#39;blah&#39;).parse_string(&#39;blah&#39;)  # -&gt; [&#39;blah&#39;]</span>
<span class="sd">        Literal(&#39;blah&#39;).parse_string(&#39;blahfooblah&#39;)  # -&gt; [&#39;blah&#39;]</span>
<span class="sd">        Literal(&#39;blah&#39;).parse_string(&#39;bla&#39;)  # -&gt; Exception: Expected &quot;blah&quot;</span>

<span class="sd">    For case-insensitive matching, use :class:`CaselessLiteral`.</span>

<span class="sd">    For keyword matching (force word break before and after the matched string),</span>
<span class="sd">    use :class:`Keyword` or :class:`CaselessKeyword`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">matchString</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">match_string</span> <span class="o">=</span> <span class="n">matchString</span> <span class="ow">or</span> <span class="n">match_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">match_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_string</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="o">=</span> <span class="n">match_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;null string passed to Literal; use Empty() instead&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Performance tuning: modify __class__ to select</span>
        <span class="c1"># a parseImpl optimized for single-character check</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Literal</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">_SingleCharLiteral</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="ow">and</span> <span class="n">instring</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">,</span> <span class="n">loc</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_SingleCharLiteral</span><span class="p">(</span><span class="n">Literal</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span> <span class="o">=</span> <span class="n">Literal</span>


<span class="k">class</span> <span class="nc">Keyword</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Token to exactly match a specified string as a keyword, that is,</span>
<span class="sd">    it must be immediately followed by a non-keyword character.  Compare</span>
<span class="sd">    with :class:`Literal`:</span>

<span class="sd">    - ``Literal(&quot;if&quot;)`` will match the leading ``&#39;if&#39;`` in</span>
<span class="sd">      ``&#39;ifAndOnlyIf&#39;``.</span>
<span class="sd">    - ``Keyword(&quot;if&quot;)`` will not; it will only match the leading</span>
<span class="sd">      ``&#39;if&#39;`` in ``&#39;if x=1&#39;``, or ``&#39;if(y==2)&#39;``</span>

<span class="sd">    Accepts two optional constructor arguments in addition to the</span>
<span class="sd">    keyword string:</span>

<span class="sd">    - ``identChars`` is a string of characters that would be valid</span>
<span class="sd">      identifier characters, defaulting to all alphanumerics + &quot;_&quot; and</span>
<span class="sd">      &quot;$&quot;</span>
<span class="sd">    - ``caseless`` allows case-insensitive matching, default is ``False``.</span>

<span class="sd">    Example::</span>

<span class="sd">        Keyword(&quot;start&quot;).parse_string(&quot;start&quot;)  # -&gt; [&#39;start&#39;]</span>
<span class="sd">        Keyword(&quot;start&quot;).parse_string(&quot;starting&quot;)  # -&gt; Exception</span>

<span class="sd">    For case-insensitive matching, use :class:`CaselessKeyword`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">DEFAULT_KEYWORD_CHARS</span> <span class="o">=</span> <span class="n">alphanums</span> <span class="o">+</span> <span class="s2">&quot;_$&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">match_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">ident_chars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">caseless</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">matchString</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">identChars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">identChars</span> <span class="o">=</span> <span class="n">identChars</span> <span class="ow">or</span> <span class="n">ident_chars</span>
        <span class="k">if</span> <span class="n">identChars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">identChars</span> <span class="o">=</span> <span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span>
        <span class="n">match_string</span> <span class="o">=</span> <span class="n">matchString</span> <span class="ow">or</span> <span class="n">match_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">match_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_string</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="o">=</span> <span class="n">match_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;null string passed to Keyword; use Empty() instead&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">caseless</span> <span class="o">=</span> <span class="n">caseless</span>
        <span class="k">if</span> <span class="n">caseless</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">caselessmatch</span> <span class="o">=</span> <span class="n">match_string</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">identChars</span> <span class="o">=</span> <span class="n">identChars</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">identChars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span>
        <span class="n">errloc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">caseless</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="p">:</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">caselessmatch</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span>
                        <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># followed by keyword char</span>
                        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s2">&quot;, was immediately followed by keyword character&quot;</span>
                        <span class="n">errloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># preceded by keyword char</span>
                    <span class="n">errmsg</span> <span class="o">+=</span> <span class="s2">&quot;, keyword was immediately preceded by keyword character&quot;</span>
                    <span class="n">errloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># else no match just raise plain exception</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">or</span> <span class="n">instring</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span>
                        <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># followed by keyword char</span>
                        <span class="n">errmsg</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="s2">&quot;, keyword was immediately followed by keyword character&quot;</span>
                        <span class="p">)</span>
                        <span class="n">errloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># preceded by keyword char</span>
                    <span class="n">errmsg</span> <span class="o">+=</span> <span class="s2">&quot;, keyword was immediately preceded by keyword character&quot;</span>
                    <span class="n">errloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># else no match just raise plain exception</span>

        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">errloc</span><span class="p">,</span> <span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">set_default_keyword_chars</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Overrides the default characters used by :class:`Keyword` expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span> <span class="o">=</span> <span class="n">chars</span>

    <span class="n">setDefaultKeywordChars</span> <span class="o">=</span> <span class="n">set_default_keyword_chars</span>


<span class="k">class</span> <span class="nc">CaselessLiteral</span><span class="p">(</span><span class="n">Literal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Token to match a specified string, ignoring case of letters.</span>
<span class="sd">    Note: the matched results will always be in the case of the given</span>
<span class="sd">    match string, NOT the case of the input text.</span>

<span class="sd">    Example::</span>

<span class="sd">        CaselessLiteral(&quot;CMD&quot;)[1, ...].parse_string(&quot;cmd CMD Cmd10&quot;)</span>
<span class="sd">        # -&gt; [&#39;CMD&#39;, &#39;CMD&#39;, &#39;CMD&#39;]</span>

<span class="sd">    (Contrast with example for :class:`CaselessKeyword`.)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">match_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">matchString</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="n">match_string</span> <span class="o">=</span> <span class="n">matchString</span> <span class="ow">or</span> <span class="n">match_string</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">match_string</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="c1"># Preserve the defining literal.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">returnString</span> <span class="o">=</span> <span class="n">match_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="p">:</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">returnString</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CaselessKeyword</span><span class="p">(</span><span class="n">Keyword</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Caseless version of :class:`Keyword`.</span>

<span class="sd">    Example::</span>

<span class="sd">        CaselessKeyword(&quot;CMD&quot;)[1, ...].parse_string(&quot;cmd CMD Cmd10&quot;)</span>
<span class="sd">        # -&gt; [&#39;CMD&#39;, &#39;CMD&#39;]</span>

<span class="sd">    (Contrast with example for :class:`CaselessLiteral`.)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">match_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">ident_chars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">matchString</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">identChars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">identChars</span> <span class="o">=</span> <span class="n">identChars</span> <span class="ow">or</span> <span class="n">ident_chars</span>
        <span class="n">match_string</span> <span class="o">=</span> <span class="n">matchString</span> <span class="ow">or</span> <span class="n">match_string</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">match_string</span><span class="p">,</span> <span class="n">identChars</span><span class="p">,</span> <span class="n">caseless</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CloseMatch</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A variation on :class:`Literal` which matches &quot;close&quot; matches,</span>
<span class="sd">    that is, strings with at most &#39;n&#39; mismatching characters.</span>
<span class="sd">    :class:`CloseMatch` takes parameters:</span>

<span class="sd">    - ``match_string`` - string to be matched</span>
<span class="sd">    - ``caseless`` - a boolean indicating whether to ignore casing when comparing characters</span>
<span class="sd">    - ``max_mismatches`` - (``default=1``) maximum number of</span>
<span class="sd">      mismatches allowed to count as a match</span>

<span class="sd">    The results from a successful parse will contain the matched text</span>
<span class="sd">    from the input string and the following named results:</span>

<span class="sd">    - ``mismatches`` - a list of the positions within the</span>
<span class="sd">      match_string where mismatches were found</span>
<span class="sd">    - ``original`` - the original match_string used to compare</span>
<span class="sd">      against the input string</span>

<span class="sd">    If ``mismatches`` is an empty list, then the match was an exact</span>
<span class="sd">    match.</span>

<span class="sd">    Example::</span>

<span class="sd">        patt = CloseMatch(&quot;ATCATCGAATGGA&quot;)</span>
<span class="sd">        patt.parse_string(&quot;ATCATCGAAXGGA&quot;) # -&gt; ([&#39;ATCATCGAAXGGA&#39;], {&#39;mismatches&#39;: [[9]], &#39;original&#39;: [&#39;ATCATCGAATGGA&#39;]})</span>
<span class="sd">        patt.parse_string(&quot;ATCAXCGAAXGGA&quot;) # -&gt; Exception: Expected &#39;ATCATCGAATGGA&#39; (with up to 1 mismatches) (at char 0), (line:1, col:1)</span>

<span class="sd">        # exact match</span>
<span class="sd">        patt.parse_string(&quot;ATCATCGAATGGA&quot;) # -&gt; ([&#39;ATCATCGAATGGA&#39;], {&#39;mismatches&#39;: [[]], &#39;original&#39;: [&#39;ATCATCGAATGGA&#39;]})</span>

<span class="sd">        # close match allowing up to 2 mismatches</span>
<span class="sd">        patt = CloseMatch(&quot;ATCATCGAATGGA&quot;, max_mismatches=2)</span>
<span class="sd">        patt.parse_string(&quot;ATCAXCGAAXGGA&quot;) # -&gt; ([&#39;ATCAXCGAAXGGA&#39;], {&#39;mismatches&#39;: [[4, 9]], &#39;original&#39;: [&#39;ATCATCGAATGGA&#39;]})</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">match_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">max_mismatches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">maxMismatches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">caseless</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">maxMismatches</span> <span class="o">=</span> <span class="n">max_mismatches</span> <span class="k">if</span> <span class="n">max_mismatches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">maxMismatches</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_string</span> <span class="o">=</span> <span class="n">match_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxMismatches</span> <span class="o">=</span> <span class="n">maxMismatches</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected </span><span class="si">{!r}</span><span class="s2"> (with up to </span><span class="si">{}</span><span class="s2"> mismatches)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_string</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxMismatches</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">caseless</span> <span class="o">=</span> <span class="n">caseless</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_string</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match_string</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxloc</span> <span class="o">&lt;=</span> <span class="n">instrlen</span><span class="p">:</span>
            <span class="n">match_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_string</span>
            <span class="n">match_stringloc</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">mismatches</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">maxMismatches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxMismatches</span>

            <span class="k">for</span> <span class="n">match_stringloc</span><span class="p">,</span> <span class="n">s_m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">:</span><span class="n">maxloc</span><span class="p">],</span> <span class="n">match_string</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">src</span><span class="p">,</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">s_m</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">caseless</span><span class="p">:</span>
                    <span class="n">src</span><span class="p">,</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">mat</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">src</span> <span class="o">!=</span> <span class="n">mat</span><span class="p">:</span>
                    <span class="n">mismatches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">match_stringloc</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxMismatches</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">match_stringloc</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">([</span><span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]])</span>
                <span class="n">results</span><span class="p">[</span><span class="s2">&quot;original&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_string</span>
                <span class="n">results</span><span class="p">[</span><span class="s2">&quot;mismatches&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mismatches</span>
                <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">results</span>

        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Word</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Token for matching words composed of allowed character sets.</span>
<span class="sd">    Parameters:</span>
<span class="sd">    - ``init_chars`` - string of all characters that should be used to</span>
<span class="sd">      match as a word; &quot;ABC&quot; will match &quot;AAA&quot;, &quot;ABAB&quot;, &quot;CBAC&quot;, etc.;</span>
<span class="sd">      if ``body_chars`` is also specified, then this is the string of</span>
<span class="sd">      initial characters</span>
<span class="sd">    - ``body_chars`` - string of characters that</span>
<span class="sd">      can be used for matching after a matched initial character as</span>
<span class="sd">      given in ``init_chars``; if omitted, same as the initial characters</span>
<span class="sd">      (default=``None``)</span>
<span class="sd">    - ``min`` - minimum number of characters to match (default=1)</span>
<span class="sd">    - ``max`` - maximum number of characters to match (default=0)</span>
<span class="sd">    - ``exact`` - exact number of characters to match (default=0)</span>
<span class="sd">    - ``as_keyword`` - match as a keyword (default=``False``)</span>
<span class="sd">    - ``exclude_chars`` - characters that might be</span>
<span class="sd">      found in the input ``body_chars`` string but which should not be</span>
<span class="sd">      accepted for matching ;useful to define a word of all</span>
<span class="sd">      printables except for one or two characters, for instance</span>
<span class="sd">      (default=``None``)</span>

<span class="sd">    :class:`srange` is useful for defining custom character set strings</span>
<span class="sd">    for defining :class:`Word` expressions, using range notation from</span>
<span class="sd">    regular expression character sets.</span>

<span class="sd">    A common mistake is to use :class:`Word` to match a specific literal</span>
<span class="sd">    string, as in ``Word(&quot;Address&quot;)``. Remember that :class:`Word`</span>
<span class="sd">    uses the string argument to define *sets* of matchable characters.</span>
<span class="sd">    This expression would match &quot;Add&quot;, &quot;AAA&quot;, &quot;dAred&quot;, or any other word</span>
<span class="sd">    made up of the characters &#39;A&#39;, &#39;d&#39;, &#39;r&#39;, &#39;e&#39;, and &#39;s&#39;. To match an</span>
<span class="sd">    exact literal string, use :class:`Literal` or :class:`Keyword`.</span>

<span class="sd">    pyparsing includes helper strings for building Words:</span>

<span class="sd">    - :class:`alphas`</span>
<span class="sd">    - :class:`nums`</span>
<span class="sd">    - :class:`alphanums`</span>
<span class="sd">    - :class:`hexnums`</span>
<span class="sd">    - :class:`alphas8bit` (alphabetic characters in ASCII range 128-255</span>
<span class="sd">      - accented, tilded, umlauted, etc.)</span>
<span class="sd">    - :class:`punc8bit` (non-alphabetic characters in ASCII range</span>
<span class="sd">      128-255 - currency, symbols, superscripts, diacriticals, etc.)</span>
<span class="sd">    - :class:`printables` (any non-whitespace character)</span>

<span class="sd">    ``alphas``, ``nums``, and ``printables`` are also defined in several</span>
<span class="sd">    Unicode sets - see :class:`pyparsing_unicode``.</span>

<span class="sd">    Example::</span>

<span class="sd">        # a word composed of digits</span>
<span class="sd">        integer = Word(nums) # equivalent to Word(&quot;0123456789&quot;) or Word(srange(&quot;0-9&quot;))</span>

<span class="sd">        # a word with a leading capital, and zero or more lowercase</span>
<span class="sd">        capital_word = Word(alphas.upper(), alphas.lower())</span>

<span class="sd">        # hostnames are alphanumeric, with leading alpha, and &#39;-&#39;</span>
<span class="sd">        hostname = Word(alphas, alphanums + &#39;-&#39;)</span>

<span class="sd">        # roman numeral (not a strict parser, accepts invalid mix of characters)</span>
<span class="sd">        roman = Word(&quot;IVXLCDM&quot;)</span>

<span class="sd">        # any string of non-whitespace characters, except for &#39;,&#39;</span>
<span class="sd">        csv_value = Word(printables, exclude_chars=&quot;,&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">init_chars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">body_chars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">exact</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">as_keyword</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_chars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">initChars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bodyChars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">asKeyword</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">excludeChars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">initChars</span> <span class="o">=</span> <span class="n">initChars</span> <span class="ow">or</span> <span class="n">init_chars</span>
        <span class="n">bodyChars</span> <span class="o">=</span> <span class="n">bodyChars</span> <span class="ow">or</span> <span class="n">body_chars</span>
        <span class="n">asKeyword</span> <span class="o">=</span> <span class="n">asKeyword</span> <span class="ow">or</span> <span class="n">as_keyword</span>
        <span class="n">excludeChars</span> <span class="o">=</span> <span class="n">excludeChars</span> <span class="ow">or</span> <span class="n">exclude_chars</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">initChars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;invalid </span><span class="si">{}</span><span class="s2">, initChars cannot be empty string&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="n">initChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initChars</span> <span class="o">=</span> <span class="n">initChars</span>
        <span class="k">if</span> <span class="n">excludeChars</span><span class="p">:</span>
            <span class="n">excludeChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">excludeChars</span><span class="p">)</span>
            <span class="n">initChars</span> <span class="o">-=</span> <span class="n">excludeChars</span>
            <span class="k">if</span> <span class="n">bodyChars</span><span class="p">:</span>
                <span class="n">bodyChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bodyChars</span><span class="p">)</span> <span class="o">-</span> <span class="n">excludeChars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">initChars</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">bodyChars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">bodyChars</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bodyChars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">initChars</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initChars</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maxSpecified</span> <span class="o">=</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">min</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cannot specify a minimum length &lt; 1; use Opt(Word()) if zero-length word is permitted&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="nb">min</span>

        <span class="k">if</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">_MAX_INT</span>

        <span class="k">if</span> <span class="n">exact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">exact</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">exact</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asKeyword</span> <span class="o">=</span> <span class="n">asKeyword</span>

        <span class="c1"># see if we can make a regex for this Word</span>
        <span class="k">if</span> <span class="s2">&quot; &quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initChars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">min</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">exact</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">max</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
                <span class="k">elif</span> <span class="nb">max</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="s2">&quot;{{</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">,</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">==</span> <span class="n">_MAX_INT</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">]</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">_collapse_string_to_ranges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">),</span>
                    <span class="n">repeat</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">max</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="s2">&quot;{{0,</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">[</span><span class="si">{}</span><span class="s2">]</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">),</span>
                    <span class="n">_collapse_string_to_ranges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span><span class="p">),</span>
                    <span class="n">repeat</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">max</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>
                <span class="k">elif</span> <span class="nb">max</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="s2">&quot;{{0,</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">][</span><span class="si">{}</span><span class="s2">]</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">_collapse_string_to_ranges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">),</span>
                    <span class="n">_collapse_string_to_ranges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span><span class="p">),</span>
                    <span class="n">repeat</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asKeyword</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\b&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\b&quot;</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reString</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">re</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">_WordRegex</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">charsAsStr</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">max_repr_len</span> <span class="o">=</span> <span class="mi">16</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">_collapse_string_to_ranges</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">re_escape</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_repr_len</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span><span class="p">[:</span> <span class="n">max_repr_len</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">s</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initChars</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;W:(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">charsAsStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">),</span> <span class="n">charsAsStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;W:(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">charsAsStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">))</span>

        <span class="c1"># add length specification</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">!=</span> <span class="n">_MAX_INT</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">base</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">base</span> <span class="o">+</span> <span class="s2">&quot;{{</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">==</span> <span class="n">_MAX_INT</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">base</span> <span class="o">+</span> <span class="s2">&quot;{{</span><span class="si">{}</span><span class="s2">,...}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">base</span> <span class="o">+</span> <span class="s2">&quot;{{</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">bodychars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxloc</span><span class="p">,</span> <span class="n">instrlen</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">maxloc</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">throwException</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">:</span>
            <span class="n">throwException</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxSpecified</span> <span class="ow">and</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span><span class="p">:</span>
            <span class="n">throwException</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">asKeyword</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span>
                <span class="ow">or</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span>
                <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span>
            <span class="p">):</span>
                <span class="n">throwException</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">throwException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_WordRegex</span><span class="p">(</span><span class="n">Word</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Char</span><span class="p">(</span><span class="n">_WordRegex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A short-cut class for defining :class:`Word` ``(characters, exact=1)``,</span>
<span class="sd">    when defining a match of any single character in a string of</span>
<span class="sd">    characters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">charset</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">as_keyword</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">exclude_chars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">asKeyword</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">excludeChars</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">asKeyword</span> <span class="o">=</span> <span class="n">asKeyword</span> <span class="ow">or</span> <span class="n">as_keyword</span>
        <span class="n">excludeChars</span> <span class="o">=</span> <span class="n">excludeChars</span> <span class="ow">or</span> <span class="n">exclude_chars</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">charset</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">asKeyword</span><span class="o">=</span><span class="n">asKeyword</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="n">excludeChars</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_collapse_string_to_ranges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">asKeyword</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\b</span><span class="si">{}</span><span class="s2">\b&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reString</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reString</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span>


<span class="k">class</span> <span class="nc">Regex</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Token for matching strings that match a given regular</span>
<span class="sd">    expression. Defined with string specifying the regular expression in</span>
<span class="sd">    a form recognized by the stdlib Python  `re module &lt;https://docs.python.org/3/library/re.html&gt;`_.</span>
<span class="sd">    If the given regex contains named groups (defined using ``(?P&lt;name&gt;...)``),</span>
<span class="sd">    these will be preserved as named :class:`ParseResults`.</span>

<span class="sd">    If instead of the Python stdlib ``re`` module you wish to use a different RE module</span>
<span class="sd">    (such as the ``regex`` module), you can do so by building your ``Regex`` object with</span>
<span class="sd">    a compiled RE that was compiled using ``regex``.</span>

<span class="sd">    Example::</span>

<span class="sd">        realnum = Regex(r&quot;[+-]?\d+\.\d*&quot;)</span>
<span class="sd">        # ref: https://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression</span>
<span class="sd">        roman = Regex(r&quot;M{0,4}(CM|CD|D?{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})&quot;)</span>

<span class="sd">        # named fields in a regex will be returned as named results</span>
<span class="sd">        date = Regex(r&#39;(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d\d?)-(?P&lt;day&gt;\d\d?)&#39;)</span>

<span class="sd">        # the Regex class will accept re&#39;s compiled using the regex module</span>
<span class="sd">        import regex</span>
<span class="sd">        parser = pp.Regex(regex.compile(r&#39;[0-9]&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">pattern</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">flags</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">RegexFlag</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">as_group_list</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">as_match</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">asGroupList</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">asMatch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The parameters ``pattern`` and ``flags`` are passed</span>
<span class="sd">        to the ``re.compile()`` function as-is. See the Python</span>
<span class="sd">        `re module &lt;https://docs.python.org/3/library/re.html&gt;`_ module for an</span>
<span class="sd">        explanation of the acceptable patterns and flags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">asGroupList</span> <span class="o">=</span> <span class="n">asGroupList</span> <span class="ow">or</span> <span class="n">as_group_list</span>
        <span class="n">asMatch</span> <span class="o">=</span> <span class="n">asMatch</span> <span class="ow">or</span> <span class="n">as_match</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;null string passed to Regex; use Empty() instead&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_re</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>

        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="s2">&quot;pattern&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="s2">&quot;match&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re</span> <span class="o">=</span> <span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Regex may only be constructed with a string or a compiled RE object&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asGroupList</span> <span class="o">=</span> <span class="n">asGroupList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asMatch</span> <span class="o">=</span> <span class="n">asMatch</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asGroupList</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImplAsGroupList</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asMatch</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImplAsMatch</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">re</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">re</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;invalid pattern (</span><span class="si">{!r}</span><span class="s2">) passed to Regex&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">re_match</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">mayReturnEmpty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Re:(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">parseImplAsGroupList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">parseImplAsMatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repl</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return :class:`Regex` with an attached parse action to transform the parsed</span>
<span class="sd">        result as if called using `re.sub(expr, repl, string) &lt;https://docs.python.org/3/library/re.html#re.sub&gt;`_.</span>

<span class="sd">        Example::</span>

<span class="sd">            make_html = Regex(r&quot;(\w+):(.*?):&quot;).sub(r&quot;&lt;\1&gt;\2&lt;/\1&gt;&quot;)</span>
<span class="sd">            print(make_html.transform_string(&quot;h1:main title:&quot;))</span>
<span class="sd">            # prints &quot;&lt;h1&gt;main title&lt;/h1&gt;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asGroupList</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot use sub() with Regex(asGroupList=True)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asMatch</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">repl</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot use sub() with a callable with Regex(asMatch=True)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asMatch</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">repl</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_parse_action</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">QuotedString</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Token for matching strings that are delimited by quoting characters.</span>

<span class="sd">    Defined with the following parameters:</span>

<span class="sd">    - ``quote_char`` - string of one or more characters defining the</span>
<span class="sd">      quote delimiting string</span>
<span class="sd">    - ``esc_char`` - character to re_escape quotes, typically backslash</span>
<span class="sd">      (default= ``None``)</span>
<span class="sd">    - ``esc_quote`` - special quote sequence to re_escape an embedded quote</span>
<span class="sd">      string (such as SQL&#39;s ``&quot;&quot;`` to re_escape an embedded ``&quot;``)</span>
<span class="sd">      (default= ``None``)</span>
<span class="sd">    - ``multiline`` - boolean indicating whether quotes can span</span>
<span class="sd">      multiple lines (default= ``False``)</span>
<span class="sd">    - ``unquote_results`` - boolean indicating whether the matched text</span>
<span class="sd">      should be unquoted (default= ``True``)</span>
<span class="sd">    - ``end_quote_char`` - string of one or more characters defining the</span>
<span class="sd">      end of the quote delimited string (default= ``None``  =&gt; same as</span>
<span class="sd">      quote_char)</span>
<span class="sd">    - ``convert_whitespace_escapes`` - convert escaped whitespace</span>
<span class="sd">      (``&#39;\t&#39;``, ``&#39;\n&#39;``, etc.) to actual whitespace</span>
<span class="sd">      (default= ``True``)</span>

<span class="sd">    Example::</span>

<span class="sd">        qs = QuotedString(&#39;&quot;&#39;)</span>
<span class="sd">        print(qs.search_string(&#39;lsjdf &quot;This is the quote&quot; sldjf&#39;))</span>
<span class="sd">        complex_qs = QuotedString(&#39;{{&#39;, end_quote_char=&#39;}}&#39;)</span>
<span class="sd">        print(complex_qs.search_string(&#39;lsjdf {{This is the &quot;quote&quot;}} sldjf&#39;))</span>
<span class="sd">        sql_qs = QuotedString(&#39;&quot;&#39;, esc_quote=&#39;&quot;&quot;&#39;)</span>
<span class="sd">        print(sql_qs.search_string(&#39;lsjdf &quot;This is the quote with &quot;&quot;embedded&quot;&quot; quotes&quot; sldjf&#39;))</span>

<span class="sd">    prints::</span>

<span class="sd">        [[&#39;This is the quote&#39;]]</span>
<span class="sd">        [[&#39;This is the &quot;quote&quot;&#39;]]</span>
<span class="sd">        [[&#39;This is the quote with &quot;embedded&quot; quotes&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ws_map</span> <span class="o">=</span> <span class="p">((</span><span class="sa">r</span><span class="s2">&quot;\t&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">),</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\n&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">),</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\f&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\f</span><span class="s2">&quot;</span><span class="p">),</span> <span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\r&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">quote_char</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">esc_char</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">esc_quote</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">multiline</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">unquote_results</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">end_quote_char</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">convert_whitespace_escapes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">quoteChar</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">escChar</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">escQuote</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unquoteResults</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">endQuoteChar</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">convertWhitespaceEscapes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">escChar</span> <span class="o">=</span> <span class="n">escChar</span> <span class="ow">or</span> <span class="n">esc_char</span>
        <span class="n">escQuote</span> <span class="o">=</span> <span class="n">escQuote</span> <span class="ow">or</span> <span class="n">esc_quote</span>
        <span class="n">unquoteResults</span> <span class="o">=</span> <span class="n">unquoteResults</span> <span class="ow">and</span> <span class="n">unquote_results</span>
        <span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">endQuoteChar</span> <span class="ow">or</span> <span class="n">end_quote_char</span>
        <span class="n">convertWhitespaceEscapes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">convertWhitespaceEscapes</span> <span class="ow">and</span> <span class="n">convert_whitespace_escapes</span>
        <span class="p">)</span>
        <span class="n">quote_char</span> <span class="o">=</span> <span class="n">quoteChar</span> <span class="ow">or</span> <span class="n">quote_char</span>

        <span class="c1"># remove white space from quote chars - wont work anyway</span>
        <span class="n">quote_char</span> <span class="o">=</span> <span class="n">quote_char</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">quote_char</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;quote_char cannot be the empty string&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">endQuoteChar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">quote_char</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">endQuoteChar</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">endQuoteChar</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;endQuoteChar cannot be the empty string&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span> <span class="o">=</span> <span class="n">quote_char</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quoteCharLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quote_char</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firstQuoteChar</span> <span class="o">=</span> <span class="n">quote_char</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">endQuoteChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteCharLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">endQuoteChar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escChar</span> <span class="o">=</span> <span class="n">escChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escQuote</span> <span class="o">=</span> <span class="n">escQuote</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unquoteResults</span> <span class="o">=</span> <span class="n">unquoteResults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convertWhitespaceEscapes</span> <span class="o">=</span> <span class="n">convertWhitespaceEscapes</span>

        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">inner_pattern</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">escQuote</span><span class="p">:</span>
            <span class="n">inner_pattern</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(?:</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">escQuote</span><span class="p">))</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span>

        <span class="k">if</span> <span class="n">escChar</span><span class="p">:</span>
            <span class="n">inner_pattern</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(?:</span><span class="si">{}</span><span class="s2">.)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">escChar</span><span class="p">))</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">escCharReplacePattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escChar</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;(.)&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">inner_pattern</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(?:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="s2">&quot;(?:</span><span class="si">{}</span><span class="s2">(?!</span><span class="si">{}</span><span class="s2">))&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[:</span><span class="n">i</span><span class="p">]),</span>
                        <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[</span><span class="n">i</span><span class="p">:]),</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
            <span class="p">)</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span>

        <span class="k">if</span> <span class="n">multiline</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span>
            <span class="n">inner_pattern</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(?:[^</span><span class="si">{}{}</span><span class="s2">])&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">sep</span><span class="p">,</span>
                <span class="n">_escape_regex_range_chars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">_escape_regex_range_chars</span><span class="p">(</span><span class="n">escChar</span><span class="p">)</span> <span class="k">if</span> <span class="n">escChar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">inner_pattern</span> <span class="o">+=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(?:[^</span><span class="si">{}</span><span class="s2">\n\r</span><span class="si">{}</span><span class="s2">])&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">sep</span><span class="p">,</span>
                <span class="n">_escape_regex_range_chars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">_escape_regex_range_chars</span><span class="p">(</span><span class="n">escChar</span><span class="p">)</span> <span class="k">if</span> <span class="n">escChar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">),</span>
                <span class="s2">&quot;(?:&quot;</span><span class="p">,</span>
                <span class="n">inner_pattern</span><span class="p">,</span>
                <span class="s2">&quot;)*&quot;</span><span class="p">,</span>
                <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span>
        <span class="k">except</span> <span class="n">re</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;invalid pattern </span><span class="si">{!r}</span><span class="s2"> passed to Regex&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;string enclosed in </span><span class="si">{!r}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;quoted string, starting with </span><span class="si">{}</span><span class="s2"> ending with </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstQuoteChar</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">re_match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="ow">or</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unquoteResults</span><span class="p">:</span>

            <span class="c1"># strip off quotes</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteCharLen</span> <span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteCharLen</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
                <span class="c1"># replace escaped whitespace</span>
                <span class="k">if</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="n">ret</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertWhitespaceEscapes</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">wslit</span><span class="p">,</span> <span class="n">wschar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ws_map</span><span class="p">:</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">wslit</span><span class="p">,</span> <span class="n">wschar</span><span class="p">)</span>

                <span class="c1"># replace escaped characters</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escChar</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escCharReplacePattern</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\g&lt;1&gt;&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>

                <span class="c1"># replace escaped quotes</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escQuote</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escQuote</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">CharsNotIn</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Token for matching words composed of characters *not* in a given</span>
<span class="sd">    set (will include whitespace in matched characters if not listed in</span>
<span class="sd">    the provided exclusion set - see example). Defined with string</span>
<span class="sd">    containing all disallowed characters, and an optional minimum,</span>
<span class="sd">    maximum, and/or exact length.  The default value for ``min`` is</span>
<span class="sd">    1 (a minimum value &lt; 1 is not valid); the default values for</span>
<span class="sd">    ``max`` and ``exact`` are 0, meaning no maximum or exact</span>
<span class="sd">    length restriction.</span>

<span class="sd">    Example::</span>

<span class="sd">        # define a comma-separated-value as anything that is not a &#39;,&#39;</span>
<span class="sd">        csv_value = CharsNotIn(&#39;,&#39;)</span>
<span class="sd">        print(delimited_list(csv_value).parse_string(&quot;dkls,lsdkjf,s12 34,@!#,213&quot;))</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;dkls&#39;, &#39;lsdkjf&#39;, &#39;s12 34&#39;, &#39;@!#&#39;, &#39;213&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">not_chars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">exact</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">notChars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span> <span class="o">=</span> <span class="n">not_chars</span> <span class="ow">or</span> <span class="n">notChars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notCharsSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">min</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;cannot specify a minimum length &lt; 1; use &quot;</span>
                <span class="s2">&quot;Opt(CharsNotIn()) if zero-length char group is permitted&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="nb">min</span>

        <span class="k">if</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">_MAX_INT</span>

        <span class="k">if</span> <span class="n">exact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">exact</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">exact</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">not_chars_str</span> <span class="o">=</span> <span class="n">_collapse_string_to_ranges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">not_chars_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;!W:(</span><span class="si">{}</span><span class="s2">...)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">[:</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">3</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;!W:(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">notchars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">notCharsSet</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">notchars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">maxlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">notchars</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">White</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special matching class for matching whitespace.  Normally,</span>
<span class="sd">    whitespace is ignored by pyparsing grammars.  This class is included</span>
<span class="sd">    when some whitespace structures are significant.  Define with</span>
<span class="sd">    a string containing the whitespace characters to be matched; default</span>
<span class="sd">    is ``&quot; \\t\\r\\n&quot;``.  Also takes optional ``min``,</span>
<span class="sd">    ``max``, and ``exact`` arguments, as defined for the</span>
<span class="sd">    :class:`Word` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">whiteStrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot; &quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;SP&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;TAB&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;LF&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;CR&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\f</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;FF&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u00A0</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;NBSP&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u1680</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;OGHAM_SPACE_MARK&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u180E</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;MONGOLIAN_VOWEL_SEPARATOR&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2000</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;EN_QUAD&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2001</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;EM_QUAD&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2002</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;EN_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2003</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;EM_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2004</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;THREE-PER-EM_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2005</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;FOUR-PER-EM_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2006</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;SIX-PER-EM_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2007</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;FIGURE_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2008</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;PUNCTUATION_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u2009</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;THIN_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u200A</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;HAIR_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u200B</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;ZERO_WIDTH_SPACE&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u202F</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;NNBSP&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u205F</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;MMSP&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\u3000</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;IDEOGRAPHIC_SPACE&gt;&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ws</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\t\r\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">exact</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span> <span class="o">=</span> <span class="n">ws</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_whitespace_chars</span><span class="p">(</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiteStrs</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">),</span>
            <span class="n">copy_defaults</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># self.leave_whitespace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="nb">min</span>

        <span class="k">if</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">_MAX_INT</span>

        <span class="k">if</span> <span class="n">exact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">exact</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">exact</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">White</span><span class="o">.</span><span class="n">whiteStrs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxloc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">))</span>
        <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">maxloc</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">PositionToken</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">GoToColumn</span><span class="p">(</span><span class="n">PositionToken</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Token to advance to a specific column of input text; useful for</span>
<span class="sd">    tabular report scraping.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">colno</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">colno</span>

    <span class="k">def</span> <span class="nf">preParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
            <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipIgnorables</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">while</span> <span class="p">(</span>
                <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span>
                <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span>
                <span class="ow">and</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span>
            <span class="p">):</span>
                <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">thiscol</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">thiscol</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;Text not in expected column&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">newloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="n">thiscol</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">:</span><span class="n">newloc</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">newloc</span><span class="p">,</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">LineStart</span><span class="p">(</span><span class="n">PositionToken</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Matches if current position is at the beginning of a line within</span>
<span class="sd">    the parse string</span>

<span class="sd">    Example::</span>

<span class="sd">        test = &#39;&#39;&#39;\</span>
<span class="sd">        AAA this line</span>
<span class="sd">        AAA and this line</span>
<span class="sd">          AAA but not this one</span>
<span class="sd">        B AAA and definitely not this one</span>
<span class="sd">        &#39;&#39;&#39;</span>

<span class="sd">        for t in (LineStart() + &#39;AAA&#39; + restOfLine).search_string(test):</span>
<span class="sd">            print(t)</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;AAA&#39;, &#39; this line&#39;]</span>
<span class="sd">        [&#39;AAA&#39;, &#39; and this line&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leave_whitespace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_whiteChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipper</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">set_whitespace_chars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected start of line&quot;</span>

    <span class="k">def</span> <span class="nf">preParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skipper</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_whiteChars</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">instring</span><span class="p">[</span><span class="n">ret</span> <span class="p">:</span> <span class="n">ret</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skipper</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">ret</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LineEnd</span><span class="p">(</span><span class="n">PositionToken</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Matches if current position is at the end of a line within the</span>
<span class="sd">    parse string</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_whitespace_chars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span><span class="p">,</span> <span class="n">copy_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected end of line&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">StringStart</span><span class="p">(</span><span class="n">PositionToken</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Matches if current position is at the beginning of the parse</span>
<span class="sd">    string</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected start of text&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># see if entire string up to here is just whitespace and ignoreables</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">StringEnd</span><span class="p">(</span><span class="n">PositionToken</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches if current position is at the end of the parse string</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected end of text&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">WordStart</span><span class="p">(</span><span class="n">PositionToken</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Matches if the current position is at the beginning of a</span>
<span class="sd">    :class:`Word`, and is not preceded by any character in a given</span>
<span class="sd">    set of ``word_chars`` (default= ``printables``). To emulate the</span>
<span class="sd">    ``\b`` behavior of regular expressions, use</span>
<span class="sd">    ``WordStart(alphanums)``. ``WordStart`` will also match at</span>
<span class="sd">    the beginning of the string being parsed, or at the beginning of</span>
<span class="sd">    a line.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word_chars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">printables</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">wordChars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">printables</span><span class="p">):</span>
        <span class="n">wordChars</span> <span class="o">=</span> <span class="n">word_chars</span> <span class="k">if</span> <span class="n">wordChars</span> <span class="o">==</span> <span class="n">printables</span> <span class="k">else</span> <span class="n">wordChars</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Not at the start of a word&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span>
                <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">WordEnd</span><span class="p">(</span><span class="n">PositionToken</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Matches if the current position is at the end of a :class:`Word`,</span>
<span class="sd">    and is not followed by any character in a given set of ``word_chars``</span>
<span class="sd">    (default= ``printables``). To emulate the ``\b`` behavior of</span>
<span class="sd">    regular expressions, use ``WordEnd(alphanums)``. ``WordEnd``</span>
<span class="sd">    will also match at the end of the string being parsed, or at the end</span>
<span class="sd">    of a line.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word_chars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">printables</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">wordChars</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">printables</span><span class="p">):</span>
        <span class="n">wordChars</span> <span class="o">=</span> <span class="n">word_chars</span> <span class="k">if</span> <span class="n">wordChars</span> <span class="o">==</span> <span class="n">printables</span> <span class="k">else</span> <span class="n">wordChars</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Not at the end of a word&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">instrlen</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span>
                <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">ParseExpression</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract subclass of ParserElement, for combining and</span>
<span class="sd">    post-processing parsed tokens.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">],</span> <span class="n">savelist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">savelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">_generatorType</span><span class="p">):</span>
            <span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">exprs</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">exprs</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
            <span class="c1"># if sequence of strings provided, wrap with Literal</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">str_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">):</span>
                <span class="n">exprs</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">str_type</span><span class="p">)</span> <span class="k">else</span> <span class="n">e</span>
                    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exprs</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">exprs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:]</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_defaultName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">leave_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extends ``leave_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on</span>
<span class="sd">           all contained expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">leave_whitespace</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">leave_whitespace</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extends ``ignore_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on</span>
<span class="sd">           all contained expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">ignore_whitespace</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">ignore_whitespace</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Suppress</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="c1"># collapse nested :class:`And`&#39;s of the form ``And(And(And(a, b), c), d)`` to ``And(a, b, c, d)``</span>
        <span class="c1"># but only if there are no parse actions or resultsNames on the nested And&#39;s</span>
        <span class="c1"># (likewise for :class:`Or`&#39;s and :class:`MatchFirst`&#39;s)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">parseAction</span>
                <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">resultsName</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">debug</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_defaultName</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayIndexError</span>

            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">parseAction</span>
                <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">resultsName</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">debug</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_defaultName</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayIndexError</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">validateTrace</span> <span class="k">if</span> <span class="n">validateTrace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[])[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkRecursion</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span>
            <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span>
            <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">resultsName</span>
                    <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span>
                    <span class="ow">not</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">suppress_warnings_</span>
                <span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: setting results name </span><span class="si">{!r}</span><span class="s2"> on </span><span class="si">{}</span><span class="s2"> expression &quot;</span>
                        <span class="s2">&quot;collides with </span><span class="si">{!r}</span><span class="s2"> on contained expression&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="s2">&quot;warn_ungrouped_named_tokens_in_collection&quot;</span><span class="p">,</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                            <span class="n">e</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>

    <span class="n">ignoreWhitespace</span> <span class="o">=</span> <span class="n">ignore_whitespace</span>
    <span class="n">leaveWhitespace</span> <span class="o">=</span> <span class="n">leave_whitespace</span>


<span class="k">class</span> <span class="nc">And</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Requires all given :class:`ParseExpression` s to be found in the given order.</span>
<span class="sd">    Expressions may be separated by whitespace.</span>
<span class="sd">    May be constructed using the ``&#39;+&#39;`` operator.</span>
<span class="sd">    May also be constructed using the ``&#39;-&#39;`` operator, which will</span>
<span class="sd">    suppress backtracking.</span>

<span class="sd">    Example::</span>

<span class="sd">        integer = Word(nums)</span>
<span class="sd">        name_expr = Word(alphas)[1, ...]</span>

<span class="sd">        expr = And([integer(&quot;id&quot;), name_expr(&quot;name&quot;), integer(&quot;age&quot;)])</span>
<span class="sd">        # more easily written as:</span>
<span class="sd">        expr = integer(&quot;id&quot;) + name_expr(&quot;name&quot;) + integer(&quot;age&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">_ErrorStop</span><span class="p">(</span><span class="n">Empty</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leave_whitespace</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;-&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">exprs_arg</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">],</span> <span class="n">savelist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
        <span class="n">exprs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs_arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exprs</span> <span class="ow">and</span> <span class="bp">Ellipsis</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">skipto_arg</span><span class="p">:</span> <span class="n">ParserElement</span> <span class="o">=</span> <span class="p">(</span><span class="n">Empty</span><span class="p">()</span> <span class="o">+</span> <span class="n">exprs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SkipTo</span><span class="p">(</span><span class="n">skipto_arg</span><span class="p">)(</span><span class="s2">&quot;_skipped*&quot;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                            <span class="s2">&quot;cannot construct And with sequence ending in ...&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">exprs</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">White</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_whitespace_chars</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">whiteChars</span><span class="p">,</span>
                    <span class="n">copy_defaults</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">skipWhitespace</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="c1"># collapse any _PendingSkip&#39;s</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ParseExpression</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">exprs</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_PendingSkip</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ParseExpression</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">exprs</span>
                        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_PendingSkip</span><span class="p">)</span>
                    <span class="p">):</span>
                        <span class="n">e</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="c1"># link any IndentedBlocks to the prior expression</span>
        <span class="k">for</span> <span class="n">prev</span><span class="p">,</span> <span class="n">cur</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="c1"># traverse cur or any first embedded expr of cur looking for an IndentedBlock</span>
            <span class="c1"># (but watch out for recursive grammar)</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">cur</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">IndentedBlock</span><span class="p">):</span>
                    <span class="n">prev</span><span class="o">.</span><span class="n">add_parse_action</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">cur_</span><span class="o">=</span><span class="n">cur</span><span class="p">:</span> <span class="nb">setattr</span><span class="p">(</span>
                            <span class="n">cur_</span><span class="p">,</span> <span class="s2">&quot;parent_anchor&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">break</span>
                <span class="n">subs</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">recurse</span><span class="p">()</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">subs</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># pass False as callPreParse arg to _parse for first element, since we already</span>
        <span class="c1"># pre-parsed the string as part of our And pre-parsing</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">resultlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span>
            <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">errorStop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c1"># if isinstance(e, And._ErrorStop):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">is</span> <span class="n">And</span><span class="o">.</span><span class="n">_ErrorStop</span><span class="p">:</span>
                <span class="n">errorStop</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">errorStop</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">loc</span><span class="p">,</span> <span class="n">exprtokens</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseSyntaxException</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
                    <span class="n">pe</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">raise</span> <span class="n">ParseSyntaxException</span><span class="o">.</span><span class="n">_from_exception</span><span class="p">(</span><span class="n">pe</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseSyntaxException</span><span class="p">(</span>
                        <span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">exprtokens</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exprtokens</span> <span class="ow">or</span> <span class="n">exprtokens</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
                <span class="n">resultlist</span> <span class="o">+=</span> <span class="n">exprtokens</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">resultlist</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  <span class="c1"># And([self, other])</span>

    <span class="k">def</span> <span class="nf">_checkRecursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">_checkRecursion</span><span class="p">(</span><span class="n">subRecCheckList</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="c1"># strip off redundant inner {}&#39;s</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">inner</span><span class="p">[</span><span class="mi">0</span> <span class="p">::</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">inner</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>


<span class="k">class</span> <span class="nc">Or</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Requires that at least one :class:`ParseExpression` is found. If</span>
<span class="sd">    two expressions match, the expression that matches the longest</span>
<span class="sd">    string will be used. May be constructed using the ``&#39;^&#39;``</span>
<span class="sd">    operator.</span>

<span class="sd">    Example::</span>

<span class="sd">        # construct Or using &#39;^&#39; operator</span>

<span class="sd">        number = Word(nums) ^ Combine(Word(nums) + &#39;.&#39; + Word(nums))</span>
<span class="sd">        print(number.search_string(&quot;123 3.1416 789&quot;))</span>

<span class="sd">    prints::</span>

<span class="sd">        [[&#39;123&#39;], [&#39;3.1416&#39;], [&#39;789&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">],</span> <span class="n">savelist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">saveAsList</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">e</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">White</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">maxException</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fatals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">callPreparse</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">):</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">loc2</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">try_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">raise_fatal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ParseFatalException</span> <span class="k">as</span> <span class="n">pfe</span><span class="p">:</span>
                <span class="n">pfe</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">pfe</span><span class="o">.</span><span class="n">parserElement</span> <span class="o">=</span> <span class="n">e</span>
                <span class="n">fatals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pfe</span><span class="p">)</span>
                <span class="n">maxException</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">fatals</span><span class="p">:</span>
                    <span class="n">err</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                        <span class="n">maxException</span> <span class="o">=</span> <span class="n">err</span>
                        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span>
                        <span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="n">e</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span>
                    <span class="p">)</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># save match among all matches, to retry longest to shortest</span>
                <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc2</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
            <span class="c1"># re-evaluate all matches in descending order of length of match, in case attached actions</span>
            <span class="c1"># might change whether or how much they match of the input.</span>
            <span class="n">matches</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">doActions</span><span class="p">:</span>
                <span class="c1"># no further conditions or parse actions to change the selection of</span>
                <span class="c1"># alternative, so the first match will be the best match</span>
                <span class="n">best_expr</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">best_expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>

            <span class="n">longest</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">loc1</span><span class="p">,</span> <span class="n">expr1</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">loc1</span> <span class="o">&lt;=</span> <span class="n">longest</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># already have a longer match than this one will deliver, we are done</span>
                    <span class="k">return</span> <span class="n">longest</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">loc2</span><span class="p">,</span> <span class="n">toks</span> <span class="o">=</span> <span class="n">expr1</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="n">err</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                        <span class="n">maxException</span> <span class="o">=</span> <span class="n">err</span>
                        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">loc2</span> <span class="o">&gt;=</span> <span class="n">loc1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">loc2</span><span class="p">,</span> <span class="n">toks</span>
                    <span class="c1"># didn&#39;t match as much as before</span>
                    <span class="k">elif</span> <span class="n">loc2</span> <span class="o">&gt;</span> <span class="n">longest</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">longest</span> <span class="o">=</span> <span class="n">loc2</span><span class="p">,</span> <span class="n">toks</span>

            <span class="k">if</span> <span class="n">longest</span> <span class="o">!=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">longest</span>

        <span class="k">if</span> <span class="n">fatals</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fatals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fatals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fatals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span> <span class="o">==</span> <span class="n">fatals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">:</span>
                    <span class="n">fatals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">parserElement</span><span class="p">))))</span>
            <span class="n">max_fatal</span> <span class="o">=</span> <span class="n">fatals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">max_fatal</span>

        <span class="k">if</span> <span class="n">maxException</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxException</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span>
            <span class="k">raise</span> <span class="n">maxException</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span>
                <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;no defined alternatives to match&quot;</span><span class="p">,</span> <span class="bp">self</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ixor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  <span class="c1"># Or([self, other])</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; ^ &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span>
            <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span>
            <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">And</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span>
                <span class="ow">not</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">suppress_warnings_</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span>
            <span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: setting results name </span><span class="si">{!r}</span><span class="s2"> on </span><span class="si">{}</span><span class="s2"> expression &quot;</span>
                    <span class="s2">&quot;will return a list of all parsed tokens in an And alternative, &quot;</span>
                    <span class="s2">&quot;in prior versions only the first token was returned; enclose &quot;</span>
                    <span class="s2">&quot;contained argument in Group&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="s2">&quot;warn_multiple_tokens_in_named_alternation&quot;</span><span class="p">,</span>
                        <span class="n">name</span><span class="p">,</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MatchFirst</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Requires that at least one :class:`ParseExpression` is found. If</span>
<span class="sd">    more than one expression matches, the first one listed is the one that will</span>
<span class="sd">    match. May be constructed using the ``&#39;|&#39;`` operator.</span>

<span class="sd">    Example::</span>

<span class="sd">        # construct MatchFirst using &#39;|&#39; operator</span>

<span class="sd">        # watch the order of expressions to match</span>
<span class="sd">        number = Word(nums) | Combine(Word(nums) + &#39;.&#39; + Word(nums))</span>
<span class="sd">        print(number.search_string(&quot;123 3.1416 789&quot;)) #  Fail! -&gt; [[&#39;123&#39;], [&#39;3&#39;], [&#39;1416&#39;], [&#39;789&#39;]]</span>

<span class="sd">        # put more selective expression first</span>
<span class="sd">        number = Combine(Word(nums) + &#39;.&#39; + Word(nums)) | Word(nums)</span>
<span class="sd">        print(number.search_string(&quot;123 3.1416 789&quot;)) #  Better -&gt; [[&#39;123&#39;], [&#39;3.1416&#39;], [&#39;789&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">],</span> <span class="n">savelist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">saveAsList</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">e</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">White</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">maxException</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span>
                    <span class="n">instring</span><span class="p">,</span>
                    <span class="n">loc</span><span class="p">,</span>
                    <span class="n">doActions</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="n">ParseFatalException</span> <span class="k">as</span> <span class="n">pfe</span><span class="p">:</span>
                <span class="n">pfe</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">pfe</span><span class="o">.</span><span class="n">parserElement</span> <span class="o">=</span> <span class="n">e</span>
                <span class="k">raise</span>
            <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">err</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span>
                        <span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="n">e</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span>
                    <span class="p">)</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">maxException</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxException</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span>
            <span class="k">raise</span> <span class="n">maxException</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span>
                <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;no defined alternatives to match&quot;</span><span class="p">,</span> <span class="bp">self</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  <span class="c1"># MatchFirst([self, other])</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span>
            <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span>
            <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">And</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_multiple_tokens_in_named_alternation</span>
                <span class="ow">not</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">suppress_warnings_</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span>
            <span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: setting results name </span><span class="si">{!r}</span><span class="s2"> on </span><span class="si">{}</span><span class="s2"> expression &quot;</span>
                    <span class="s2">&quot;will return a list of all parsed tokens in an And alternative, &quot;</span>
                    <span class="s2">&quot;in prior versions only the first token was returned; enclose &quot;</span>
                    <span class="s2">&quot;contained argument in Group&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="s2">&quot;warn_multiple_tokens_in_named_alternation&quot;</span><span class="p">,</span>
                        <span class="n">name</span><span class="p">,</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                    <span class="p">),</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Each</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Requires all given :class:`ParseExpression` s to be found, but in</span>
<span class="sd">    any order. Expressions may be separated by whitespace.</span>

<span class="sd">    May be constructed using the ``&#39;&amp;&#39;`` operator.</span>

<span class="sd">    Example::</span>

<span class="sd">        color = one_of(&quot;RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN&quot;)</span>
<span class="sd">        shape_type = one_of(&quot;SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON&quot;)</span>
<span class="sd">        integer = Word(nums)</span>
<span class="sd">        shape_attr = &quot;shape:&quot; + shape_type(&quot;shape&quot;)</span>
<span class="sd">        posn_attr = &quot;posn:&quot; + Group(integer(&quot;x&quot;) + &#39;,&#39; + integer(&quot;y&quot;))(&quot;posn&quot;)</span>
<span class="sd">        color_attr = &quot;color:&quot; + color(&quot;color&quot;)</span>
<span class="sd">        size_attr = &quot;size:&quot; + integer(&quot;size&quot;)</span>

<span class="sd">        # use Each (using operator &#39;&amp;&#39;) to accept attributes in any order</span>
<span class="sd">        # (shape and posn are required, color and size are optional)</span>
<span class="sd">        shape_spec = shape_attr &amp; posn_attr &amp; Opt(color_attr) &amp; Opt(size_attr)</span>

<span class="sd">        shape_spec.run_tests(&#39;&#39;&#39;</span>
<span class="sd">            shape: SQUARE color: BLACK posn: 100, 120</span>
<span class="sd">            shape: CIRCLE size: 50 color: BLUE posn: 50,80</span>
<span class="sd">            color:GREEN size:20 shape:TRIANGLE posn:20,40</span>
<span class="sd">            &#39;&#39;&#39;</span>
<span class="sd">            )</span>

<span class="sd">    prints::</span>

<span class="sd">        shape: SQUARE color: BLACK posn: 100, 120</span>
<span class="sd">        [&#39;shape:&#39;, &#39;SQUARE&#39;, &#39;color:&#39;, &#39;BLACK&#39;, &#39;posn:&#39;, [&#39;100&#39;, &#39;,&#39;, &#39;120&#39;]]</span>
<span class="sd">        - color: BLACK</span>
<span class="sd">        - posn: [&#39;100&#39;, &#39;,&#39;, &#39;120&#39;]</span>
<span class="sd">          - x: 100</span>
<span class="sd">          - y: 120</span>
<span class="sd">        - shape: SQUARE</span>


<span class="sd">        shape: CIRCLE size: 50 color: BLUE posn: 50,80</span>
<span class="sd">        [&#39;shape:&#39;, &#39;CIRCLE&#39;, &#39;size:&#39;, &#39;50&#39;, &#39;color:&#39;, &#39;BLUE&#39;, &#39;posn:&#39;, [&#39;50&#39;, &#39;,&#39;, &#39;80&#39;]]</span>
<span class="sd">        - color: BLUE</span>
<span class="sd">        - posn: [&#39;50&#39;, &#39;,&#39;, &#39;80&#39;]</span>
<span class="sd">          - x: 50</span>
<span class="sd">          - y: 80</span>
<span class="sd">        - shape: CIRCLE</span>
<span class="sd">        - size: 50</span>


<span class="sd">        color: GREEN size: 20 shape: TRIANGLE posn: 20,40</span>
<span class="sd">        [&#39;color:&#39;, &#39;GREEN&#39;, &#39;size:&#39;, &#39;20&#39;, &#39;shape:&#39;, &#39;TRIANGLE&#39;, &#39;posn:&#39;, [&#39;20&#39;, &#39;,&#39;, &#39;40&#39;]]</span>
<span class="sd">        - color: GREEN</span>
<span class="sd">        - posn: [&#39;20&#39;, &#39;,&#39;, &#39;40&#39;]</span>
<span class="sd">          - x: 20</span>
<span class="sd">          - y: 40</span>
<span class="sd">        - shape: TRIANGLE</span>
<span class="sd">        - size: 20</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">],</span> <span class="n">savelist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initExprGroups</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initExprGroups</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt1map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">expr</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Opt</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">opt1</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Opt</span><span class="p">)]</span>
            <span class="n">opt2</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">e</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Opt</span><span class="p">,</span> <span class="n">Regex</span><span class="p">,</span> <span class="n">ZeroOrMore</span><span class="p">))</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optionals</span> <span class="o">=</span> <span class="n">opt1</span> <span class="o">+</span> <span class="n">opt2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multioptionals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">e</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">set_results_name</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span> <span class="n">list_all_matches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">_MultipleMatch</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multirequired</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">e</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">set_results_name</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span> <span class="n">list_all_matches</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">OneOrMore</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Opt</span><span class="p">,</span> <span class="n">ZeroOrMore</span><span class="p">,</span> <span class="n">OneOrMore</span><span class="p">))</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">required</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multirequired</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initExprGroups</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">tmpLoc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">tmpReqd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">required</span><span class="p">[:]</span>
        <span class="n">tmpOpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optionals</span><span class="p">[:]</span>
        <span class="n">multis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multioptionals</span><span class="p">[:]</span>
        <span class="n">matchOrder</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">keepMatching</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fatals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">keepMatching</span><span class="p">:</span>
            <span class="n">tmpExprs</span> <span class="o">=</span> <span class="n">tmpReqd</span> <span class="o">+</span> <span class="n">tmpOpt</span> <span class="o">+</span> <span class="n">multis</span>
            <span class="n">failed</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">fatals</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpExprs</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">tmpLoc</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">try_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmpLoc</span><span class="p">,</span> <span class="n">raise_fatal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseFatalException</span> <span class="k">as</span> <span class="n">pfe</span><span class="p">:</span>
                    <span class="n">pfe</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">pfe</span><span class="o">.</span><span class="n">parserElement</span> <span class="o">=</span> <span class="n">e</span>
                    <span class="n">fatals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pfe</span><span class="p">)</span>
                    <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                    <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">matchOrder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt1map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">e</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpReqd</span><span class="p">:</span>
                        <span class="n">tmpReqd</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpOpt</span><span class="p">:</span>
                        <span class="n">tmpOpt</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmpExprs</span><span class="p">):</span>
                <span class="n">keepMatching</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># look for any ParseFatalExceptions</span>
        <span class="k">if</span> <span class="n">fatals</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fatals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fatals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fatals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span> <span class="o">==</span> <span class="n">fatals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">:</span>
                    <span class="n">fatals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">e</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">parserElement</span><span class="p">))))</span>
            <span class="n">max_fatal</span> <span class="o">=</span> <span class="n">fatals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">max_fatal</span>

        <span class="k">if</span> <span class="n">tmpReqd</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpReqd</span><span class="p">])</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span>
                <span class="n">instring</span><span class="p">,</span>
                <span class="n">loc</span><span class="p">,</span>
                <span class="s2">&quot;Missing one or more required elements (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">missing</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="c1"># add any unmatched Opts, in case they have default values defined</span>
        <span class="n">matchOrder</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Opt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="ow">in</span> <span class="n">tmpOpt</span><span class="p">]</span>

        <span class="n">total_results</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">matchOrder</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
            <span class="n">total_results</span> <span class="o">+=</span> <span class="n">results</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">total_results</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>


<span class="k">class</span> <span class="nc">ParseElementEnhance</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract subclass of :class:`ParserElement`, for combining and</span>
<span class="sd">    post-processing parsed tokens.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">savelist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">,</span> <span class="n">Token</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">Literal</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">mayIndexError</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_whitespace_chars</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">whiteChars</span><span class="p">,</span> <span class="n">copy_defaults</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">skipWhitespace</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">saveAsList</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">callPreparse</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;No expression defined&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">leave_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">leave_whitespace</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">leave_whitespace</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">ignore_whitespace</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignore_whitespace</span><span class="p">(</span><span class="n">recursive</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Suppress</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_checkRecursion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">parseElementList</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveGrammarException</span><span class="p">(</span><span class="n">parseElementList</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_checkRecursion</span><span class="p">(</span><span class="n">subRecCheckList</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">validateTrace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validateTrace</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">validateTrace</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkRecursion</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">))</span>

    <span class="n">ignoreWhitespace</span> <span class="o">=</span> <span class="n">ignore_whitespace</span>
    <span class="n">leaveWhitespace</span> <span class="o">=</span> <span class="n">leave_whitespace</span>


<span class="k">class</span> <span class="nc">IndentedBlock</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expression to match one or more expressions at a given indentation level.</span>
<span class="sd">    Useful for parsing text where structure is implied by indentation (like Python source code).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">_Indent</span><span class="p">(</span><span class="n">Empty</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_col</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;expected indent at column </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_col</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_condition</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">col</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">ref_col</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">_IndentGreater</span><span class="p">(</span><span class="n">Empty</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_col</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;expected indent at column greater than </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ref_col</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_condition</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">col</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ref_col</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParserElement</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">grouped</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># if recursive:</span>
        <span class="c1">#     raise NotImplementedError(&quot;IndentedBlock with recursive is not implemented&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recursive</span> <span class="o">=</span> <span class="n">recursive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grouped</span> <span class="o">=</span> <span class="n">grouped</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_anchor</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># advance parse position to non-whitespace by using an Empty()</span>
        <span class="c1"># this should be the column to be used for all subsequent indented lines</span>
        <span class="n">anchor_loc</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>

        <span class="c1"># see if self.expr matches at the current location - if not it will raise an exception</span>
        <span class="c1"># and no further work is necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">try_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">anchor_loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>

        <span class="n">indent_col</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="n">anchor_loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span>
        <span class="n">peer_detect_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Indent</span><span class="p">(</span><span class="n">indent_col</span><span class="p">)</span>

        <span class="n">inner_expr</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span> <span class="o">+</span> <span class="n">peer_detect_expr</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursive</span><span class="p">:</span>
            <span class="n">sub_indent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_IndentGreater</span><span class="p">(</span><span class="n">indent_col</span><span class="p">)</span>
            <span class="n">nested_block</span> <span class="o">=</span> <span class="n">IndentedBlock</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_recursive</span><span class="p">,</span> <span class="n">grouped</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_grouped</span>
            <span class="p">)</span>
            <span class="n">nested_block</span><span class="o">.</span><span class="n">set_debug</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">)</span>
            <span class="n">nested_block</span><span class="o">.</span><span class="n">parent_anchor</span> <span class="o">=</span> <span class="n">indent_col</span>
            <span class="n">inner_expr</span> <span class="o">+=</span> <span class="n">Opt</span><span class="p">(</span><span class="n">sub_indent</span> <span class="o">+</span> <span class="n">nested_block</span><span class="p">)</span>

        <span class="n">inner_expr</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inner </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">inner_expr</span><span class="p">))[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">@</span><span class="si">{</span><span class="n">indent_col</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">inner_expr</span><span class="p">)</span>

        <span class="n">trailing_undent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Indent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_anchor</span><span class="p">)</span> <span class="o">|</span> <span class="n">StringEnd</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grouped</span><span class="p">:</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="n">Group</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wrapper</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">wrapper</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">trailing_undent</span><span class="p">))</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span>
            <span class="n">instring</span><span class="p">,</span> <span class="n">anchor_loc</span><span class="p">,</span> <span class="n">doActions</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">AtStringStart</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Matches if expression matches at the beginning of the parse</span>
<span class="sd">    string::</span>

<span class="sd">        AtStringStart(Word(nums)).parse_string(&quot;123&quot;)</span>
<span class="sd">        # prints [&quot;123&quot;]</span>

<span class="sd">        AtStringStart(Word(nums)).parse_string(&quot;    123&quot;)</span>
<span class="sd">        # raises ParseException</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;not found at string start&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AtLineStart</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Matches if an expression matches at the beginning of a line within</span>
<span class="sd">    the parse string</span>

<span class="sd">    Example::</span>

<span class="sd">        test = &#39;&#39;&#39;\</span>
<span class="sd">        AAA this line</span>
<span class="sd">        AAA and this line</span>
<span class="sd">          AAA but not this one</span>
<span class="sd">        B AAA and definitely not this one</span>
<span class="sd">        &#39;&#39;&#39;</span>

<span class="sd">        for t in (AtLineStart(&#39;AAA&#39;) + restOfLine).search_string(test):</span>
<span class="sd">            print(t)</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;AAA&#39;, &#39; this line&#39;]</span>
<span class="sd">        [&#39;AAA&#39;, &#39; and this line&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;not found at line start&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FollowedBy</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lookahead matching of the given parse expression.</span>
<span class="sd">    ``FollowedBy`` does *not* advance the parsing position within</span>
<span class="sd">    the input string, it only verifies that the specified parse</span>
<span class="sd">    expression matches at the current position.  ``FollowedBy``</span>
<span class="sd">    always returns a null token list. If any results names are defined</span>
<span class="sd">    in the lookahead expression, those *will* be returned for access by</span>
<span class="sd">    name.</span>

<span class="sd">    Example::</span>

<span class="sd">        # use FollowedBy to match a label only if it is followed by a &#39;:&#39;</span>
<span class="sd">        data_word = Word(alphas)</span>
<span class="sd">        label = data_word + FollowedBy(&#39;:&#39;)</span>
<span class="sd">        attr_expr = Group(label + Suppress(&#39;:&#39;) + OneOrMore(data_word, stop_on=label).set_parse_action(&#39; &#39;.join))</span>

<span class="sd">        attr_expr[1, ...].parse_string(&quot;shape: SQUARE color: BLACK posn: upper left&quot;).pprint()</span>

<span class="sd">    prints::</span>

<span class="sd">        [[&#39;shape&#39;, &#39;SQUARE&#39;], [&#39;color&#39;, &#39;BLACK&#39;], [&#39;posn&#39;, &#39;upper left&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># by using self._expr.parse and deleting the contents of the returned ParseResults list</span>
        <span class="c1"># we keep any named results that were defined in the FollowedBy expression</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="n">doActions</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ret</span><span class="p">[:]</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">PrecededBy</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lookbehind matching of the given parse expression.</span>
<span class="sd">    ``PrecededBy`` does not advance the parsing position within the</span>
<span class="sd">    input string, it only verifies that the specified parse expression</span>
<span class="sd">    matches prior to the current position.  ``PrecededBy`` always</span>
<span class="sd">    returns a null token list, but if a results name is defined on the</span>
<span class="sd">    given expression, it is returned.</span>

<span class="sd">    Parameters:</span>

<span class="sd">    - expr - expression that must match prior to the current parse</span>
<span class="sd">      location</span>
<span class="sd">    - retreat - (default= ``None``) - (int) maximum number of characters</span>
<span class="sd">      to lookbehind prior to the current parse location</span>

<span class="sd">    If the lookbehind expression is a string, :class:`Literal`,</span>
<span class="sd">    :class:`Keyword`, or a :class:`Word` or :class:`CharsNotIn`</span>
<span class="sd">    with a specified exact or maximum length, then the retreat</span>
<span class="sd">    parameter is not required. Otherwise, retreat must be specified to</span>
<span class="sd">    give a maximum number of characters to look back from</span>
<span class="sd">    the current parse position for a lookbehind match.</span>

<span class="sd">    Example::</span>

<span class="sd">        # VB-style variable names with type prefixes</span>
<span class="sd">        int_var = PrecededBy(&quot;#&quot;) + pyparsing_common.identifier</span>
<span class="sd">        str_var = PrecededBy(&quot;$&quot;) + pyparsing_common.identifier</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">retreat</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">()</span><span class="o">.</span><span class="n">leave_whitespace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">retreat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">Literal</span><span class="p">,</span> <span class="n">Keyword</span><span class="p">)):</span>
            <span class="n">retreat</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">matchLen</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">Word</span><span class="p">,</span> <span class="n">CharsNotIn</span><span class="p">))</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">!=</span> <span class="n">_MAX_INT</span><span class="p">:</span>
            <span class="n">retreat</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">maxLen</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">PositionToken</span><span class="p">):</span>
            <span class="n">retreat</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exact</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span> <span class="o">=</span> <span class="n">retreat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;not preceded by &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exact</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># retreat specified a maximum lookbehind window, iterate</span>
            <span class="n">test_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">+</span> <span class="n">StringEnd</span><span class="p">()</span>
            <span class="n">instring_slice</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span><span class="p">)</span> <span class="p">:</span> <span class="n">loc</span><span class="p">]</span>
            <span class="n">last_expr</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">retreat</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># print(&#39;trying&#39;, offset, instring_slice, repr(instring_slice[loc - offset:]))</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">test_expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span>
                        <span class="n">instring_slice</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring_slice</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pbe</span><span class="p">:</span>
                    <span class="n">last_expr</span> <span class="o">=</span> <span class="n">pbe</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">last_expr</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span>


<span class="k">class</span> <span class="nc">Located</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorates a returned token with its starting and ending</span>
<span class="sd">    locations in the input string.</span>

<span class="sd">    This helper adds the following results names:</span>

<span class="sd">    - ``locn_start`` - location where matched expression begins</span>
<span class="sd">    - ``locn_end`` - location where matched expression ends</span>
<span class="sd">    - ``value`` - the actual parsed results</span>

<span class="sd">    Be careful if the input text contains ``&lt;TAB&gt;`` characters, you</span>
<span class="sd">    may want to call :class:`ParserElement.parse_with_tabs`</span>

<span class="sd">    Example::</span>

<span class="sd">        wd = Word(alphas)</span>
<span class="sd">        for match in Located(wd).search_string(&quot;ljsdf123lksdjjf123lkkjj1222&quot;):</span>
<span class="sd">            print(match)</span>

<span class="sd">    prints::</span>

<span class="sd">        [0, [&#39;ljsdf&#39;], 5]</span>
<span class="sd">        [8, [&#39;lksdjjf&#39;], 15]</span>
<span class="sd">        [18, [&#39;lkkjj&#39;], 23]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ret_tokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">loc</span><span class="p">])</span>
        <span class="n">ret_tokens</span><span class="p">[</span><span class="s2">&quot;locn_start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">ret_tokens</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="n">ret_tokens</span><span class="p">[</span><span class="s2">&quot;locn_end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">:</span>
            <span class="c1"># must return as a list, so that the name will be attached to the complete group</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[</span><span class="n">ret_tokens</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret_tokens</span>


<span class="k">class</span> <span class="nc">NotAny</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lookahead to disallow matching with the given parse expression.</span>
<span class="sd">    ``NotAny`` does *not* advance the parsing position within the</span>
<span class="sd">    input string, it only verifies that the specified parse expression</span>
<span class="sd">    does *not* match at the current position.  Also, ``NotAny`` does</span>
<span class="sd">    *not* skip over leading whitespace. ``NotAny`` always returns</span>
<span class="sd">    a null token list.  May be constructed using the ``&#39;~&#39;`` operator.</span>

<span class="sd">    Example::</span>

<span class="sd">        AND, OR, NOT = map(CaselessKeyword, &quot;AND OR NOT&quot;.split())</span>

<span class="sd">        # take care not to mistake keywords for identifiers</span>
<span class="sd">        ident = ~(AND | OR | NOT) + Word(alphas)</span>
<span class="sd">        boolean_term = Opt(NOT) + ident</span>

<span class="sd">        # very crude boolean expression - to support parenthesis groups and</span>
<span class="sd">        # operation hierarchy, use infix_notation</span>
<span class="sd">        boolean_expr = boolean_term + ((AND | OR) + boolean_term)[...]</span>

<span class="sd">        # integers that are followed by &quot;.&quot; are actually floats</span>
<span class="sd">        integer = Word(nums) + ~Char(&quot;.&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="c1"># do NOT use self.leave_whitespace(), don&#39;t want to propagate to exprs</span>
        <span class="c1"># self.leave_whitespace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Found unwanted token, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">can_parse_next</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;~{&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>


<span class="k">class</span> <span class="nc">_MultipleMatch</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">expr</span><span class="p">:</span> <span class="n">ParserElement</span><span class="p">,</span>
        <span class="n">stop_on</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">stopOn</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">stopOn</span> <span class="o">=</span> <span class="n">stopOn</span> <span class="ow">or</span> <span class="n">stop_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ender</span> <span class="o">=</span> <span class="n">stopOn</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ender</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">ender</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stopOn</span><span class="p">(</span><span class="n">ender</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">stopOn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ender</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ender</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">ender</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">not_ender</span> <span class="o">=</span> <span class="o">~</span><span class="n">ender</span> <span class="k">if</span> <span class="n">ender</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">self_expr_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span>
        <span class="n">self_skip_ignorables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipIgnorables</span>
        <span class="n">check_ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_ender</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">check_ender</span><span class="p">:</span>
            <span class="n">try_not_ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_ender</span><span class="o">.</span><span class="n">tryParse</span>

        <span class="c1"># must be at least one (but first see if we are the stopOn sentinel;</span>
        <span class="c1"># if so, fail)</span>
        <span class="k">if</span> <span class="n">check_ender</span><span class="p">:</span>
            <span class="n">try_not_ender</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">self_expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hasIgnoreExprs</span> <span class="o">=</span> <span class="ow">not</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">check_ender</span><span class="p">:</span>
                    <span class="n">try_not_ender</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">hasIgnoreExprs</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">self_skip_ignorables</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">loc</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">tmptokens</span> <span class="o">=</span> <span class="n">self_expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmptokens</span> <span class="ow">or</span> <span class="n">tmptokens</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
                    <span class="n">tokens</span> <span class="o">+=</span> <span class="n">tmptokens</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span>
            <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span>
            <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">recurse</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">resultsName</span>
                    <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_ungrouped_named_tokens_in_collection</span>
                    <span class="ow">not</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">suppress_warnings_</span>
                <span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: setting results name </span><span class="si">{!r}</span><span class="s2"> on </span><span class="si">{}</span><span class="s2"> expression &quot;</span>
                        <span class="s2">&quot;collides with </span><span class="si">{!r}</span><span class="s2"> on contained expression&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="s2">&quot;warn_ungrouped_named_tokens_in_collection&quot;</span><span class="p">,</span>
                            <span class="n">name</span><span class="p">,</span>
                            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                            <span class="n">e</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">OneOrMore</span><span class="p">(</span><span class="n">_MultipleMatch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Repetition of one or more of the given expression.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - expr - expression that must match one or more times</span>
<span class="sd">    - stop_on - (default= ``None``) - expression for a terminating sentinel</span>
<span class="sd">         (only required if the sentinel would ordinarily match the repetition</span>
<span class="sd">         expression)</span>

<span class="sd">    Example::</span>

<span class="sd">        data_word = Word(alphas)</span>
<span class="sd">        label = data_word + FollowedBy(&#39;:&#39;)</span>
<span class="sd">        attr_expr = Group(label + Suppress(&#39;:&#39;) + OneOrMore(data_word).set_parse_action(&#39; &#39;.join))</span>

<span class="sd">        text = &quot;shape: SQUARE posn: upper left color: BLACK&quot;</span>
<span class="sd">        attr_expr[1, ...].parse_string(text).pprint()  # Fail! read &#39;color&#39; as data instead of next label -&gt; [[&#39;shape&#39;, &#39;SQUARE color&#39;]]</span>

<span class="sd">        # use stop_on attribute for OneOrMore to avoid reading label string as part of the data</span>
<span class="sd">        attr_expr = Group(label + Suppress(&#39;:&#39;) + OneOrMore(data_word, stop_on=label).set_parse_action(&#39; &#39;.join))</span>
<span class="sd">        OneOrMore(attr_expr).parse_string(text).pprint() # Better -&gt; [[&#39;shape&#39;, &#39;SQUARE&#39;], [&#39;posn&#39;, &#39;upper left&#39;], [&#39;color&#39;, &#39;BLACK&#39;]]</span>

<span class="sd">        # could also be written as</span>
<span class="sd">        (attr_expr * (1,)).parse_string(text).pprint()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}...&quot;</span>


<span class="k">class</span> <span class="nc">ZeroOrMore</span><span class="p">(</span><span class="n">_MultipleMatch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optional repetition of zero or more of the given expression.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - ``expr`` - expression that must match zero or more times</span>
<span class="sd">    - ``stop_on`` - expression for a terminating sentinel</span>
<span class="sd">      (only required if the sentinel would ordinarily match the repetition</span>
<span class="sd">      expression) - (default= ``None``)</span>

<span class="sd">    Example: similar to :class:`OneOrMore`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">expr</span><span class="p">:</span> <span class="n">ParserElement</span><span class="p">,</span>
        <span class="n">stop_on</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">stopOn</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">stopOn</span><span class="o">=</span><span class="n">stopOn</span> <span class="ow">or</span> <span class="n">stop_on</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]...&quot;</span>


<span class="k">class</span> <span class="nc">_NullToken</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>


<span class="k">class</span> <span class="nc">Opt</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optional matching of the given expression.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - ``expr`` - expression that must match zero or more times</span>
<span class="sd">    - ``default`` (optional) - value to be returned if the optional expression is not found.</span>

<span class="sd">    Example::</span>

<span class="sd">        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier</span>
<span class="sd">        zip = Combine(Word(nums, exact=5) + Opt(&#39;-&#39; + Word(nums, exact=4)))</span>
<span class="sd">        zip.run_tests(&#39;&#39;&#39;</span>
<span class="sd">            # traditional ZIP code</span>
<span class="sd">            12345</span>

<span class="sd">            # ZIP+4 form</span>
<span class="sd">            12101-0001</span>

<span class="sd">            # invalid ZIP</span>
<span class="sd">            98765-</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">    prints::</span>

<span class="sd">        # traditional ZIP code</span>
<span class="sd">        12345</span>
<span class="sd">        [&#39;12345&#39;]</span>

<span class="sd">        # ZIP+4 form</span>
<span class="sd">        12101-0001</span>
<span class="sd">        [&#39;12101-0001&#39;]</span>

<span class="sd">        # invalid ZIP</span>
<span class="sd">        98765-</span>
<span class="sd">             ^</span>
<span class="sd">        FAIL: Expected end of text (at char 5), (line:1, col:6)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__optionalNotMatched</span> <span class="o">=</span> <span class="n">_NullToken</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">default</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">__optionalNotMatched</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">saveAsList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">self_expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">self_expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="n">default_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span>
            <span class="k">if</span> <span class="n">default_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__optionalNotMatched</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">self_expr</span><span class="o">.</span><span class="n">resultsName</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">([</span><span class="n">default_value</span><span class="p">])</span>
                    <span class="n">tokens</span><span class="p">[</span><span class="n">self_expr</span><span class="o">.</span><span class="n">resultsName</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">default_value</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
        <span class="c1"># strip off redundant inner {}&#39;s</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">inner</span><span class="p">[</span><span class="mi">0</span> <span class="p">::</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="n">inner</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>


<span class="n">Optional</span> <span class="o">=</span> <span class="n">Opt</span>


<span class="k">class</span> <span class="nc">SkipTo</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Token for skipping over all undefined text until the matched</span>
<span class="sd">    expression is found.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - ``expr`` - target expression marking the end of the data to be skipped</span>
<span class="sd">    - ``include`` - if ``True``, the target expression is also parsed</span>
<span class="sd">      (the skipped text and target expression are returned as a 2-element</span>
<span class="sd">      list) (default= ``False``).</span>
<span class="sd">    - ``ignore`` - (default= ``None``) used to define grammars (typically quoted strings and</span>
<span class="sd">      comments) that might contain false matches to the target expression</span>
<span class="sd">    - ``fail_on`` - (default= ``None``) define expressions that are not allowed to be</span>
<span class="sd">      included in the skipped test; if found before the target expression is found,</span>
<span class="sd">      the :class:`SkipTo` is not a match</span>

<span class="sd">    Example::</span>

<span class="sd">        report = &#39;&#39;&#39;</span>
<span class="sd">            Outstanding Issues Report - 1 Jan 2000</span>

<span class="sd">               # | Severity | Description                               |  Days Open</span>
<span class="sd">            -----+----------+-------------------------------------------+-----------</span>
<span class="sd">             101 | Critical | Intermittent system crash                 |          6</span>
<span class="sd">              94 | Cosmetic | Spelling error on Login (&#39;log|n&#39;)         |         14</span>
<span class="sd">              79 | Minor    | System slow when running too many reports |         47</span>
<span class="sd">            &#39;&#39;&#39;</span>
<span class="sd">        integer = Word(nums)</span>
<span class="sd">        SEP = Suppress(&#39;|&#39;)</span>
<span class="sd">        # use SkipTo to simply match everything up until the next SEP</span>
<span class="sd">        # - ignore quoted strings, so that a &#39;|&#39; character inside a quoted string does not match</span>
<span class="sd">        # - parse action will call token.strip() for each matched token, i.e., the description body</span>
<span class="sd">        string_data = SkipTo(SEP, ignore=quoted_string)</span>
<span class="sd">        string_data.set_parse_action(token_map(str.strip))</span>
<span class="sd">        ticket_expr = (integer(&quot;issue_num&quot;) + SEP</span>
<span class="sd">                      + string_data(&quot;sev&quot;) + SEP</span>
<span class="sd">                      + string_data(&quot;desc&quot;) + SEP</span>
<span class="sd">                      + integer(&quot;days_open&quot;))</span>

<span class="sd">        for tkt in ticket_expr.search_string(report):</span>
<span class="sd">            print tkt.dump()</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;101&#39;, &#39;Critical&#39;, &#39;Intermittent system crash&#39;, &#39;6&#39;]</span>
<span class="sd">        - days_open: &#39;6&#39;</span>
<span class="sd">        - desc: &#39;Intermittent system crash&#39;</span>
<span class="sd">        - issue_num: &#39;101&#39;</span>
<span class="sd">        - sev: &#39;Critical&#39;</span>
<span class="sd">        [&#39;94&#39;, &#39;Cosmetic&#39;, &quot;Spelling error on Login (&#39;log|n&#39;)&quot;, &#39;14&#39;]</span>
<span class="sd">        - days_open: &#39;14&#39;</span>
<span class="sd">        - desc: &quot;Spelling error on Login (&#39;log|n&#39;)&quot;</span>
<span class="sd">        - issue_num: &#39;94&#39;</span>
<span class="sd">        - sev: &#39;Cosmetic&#39;</span>
<span class="sd">        [&#39;79&#39;, &#39;Minor&#39;, &#39;System slow when running too many reports&#39;, &#39;47&#39;]</span>
<span class="sd">        - days_open: &#39;47&#39;</span>
<span class="sd">        - desc: &#39;System slow when running too many reports&#39;</span>
<span class="sd">        - issue_num: &#39;79&#39;</span>
<span class="sd">        - sev: &#39;Minor&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">include</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fail_on</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">failOn</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">failOn</span> <span class="o">=</span> <span class="n">failOn</span> <span class="ow">or</span> <span class="n">fail_on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExpr</span> <span class="o">=</span> <span class="n">ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">includeMatch</span> <span class="o">=</span> <span class="n">include</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">failOn</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">failOn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span> <span class="o">=</span> <span class="n">failOn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;No match found for &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">startloc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">self_expr_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span>
        <span class="n">self_failOn_canParseNext</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span><span class="o">.</span><span class="n">canParseNext</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">self_ignoreExpr_tryParse</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExpr</span><span class="o">.</span><span class="n">tryParse</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="n">tmploc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">while</span> <span class="n">tmploc</span> <span class="o">&lt;=</span> <span class="n">instrlen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self_failOn_canParseNext</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># break if failOn expression matches</span>
                <span class="k">if</span> <span class="n">self_failOn_canParseNext</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmploc</span><span class="p">):</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">self_ignoreExpr_tryParse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># advance past ignore expressions</span>
                <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">tmploc</span> <span class="o">=</span> <span class="n">self_ignoreExpr_tryParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmploc</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">ParseBaseException</span><span class="p">:</span>
                        <span class="k">break</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">self_expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmploc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                <span class="c1"># no match, advance loc in string</span>
                <span class="n">tmploc</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># matched skipto expr, done</span>
                <span class="k">break</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ran off the end of the input string without matching skipto expr, fail</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># build up return values</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">tmploc</span>
        <span class="n">skiptext</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span><span class="n">startloc</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>
        <span class="n">skipresult</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">skiptext</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">includeMatch</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">self_expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">skipresult</span> <span class="o">+=</span> <span class="n">mat</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">skipresult</span>


<span class="k">class</span> <span class="nc">Forward</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Forward declaration of an expression to be defined later -</span>
<span class="sd">    used for recursive grammars, such as algebraic infix notation.</span>
<span class="sd">    When the expression is known, it is assigned to the ``Forward``</span>
<span class="sd">    variable using the ``&#39;&lt;&lt;&#39;`` operator.</span>

<span class="sd">    Note: take care when assigning to ``Forward`` not to overlook</span>
<span class="sd">    precedence of operators.</span>

<span class="sd">    Specifically, ``&#39;|&#39;`` has a lower precedence than ``&#39;&lt;&lt;&#39;``, so that::</span>

<span class="sd">        fwd_expr &lt;&lt; a | b | c</span>

<span class="sd">    will actually be evaluated as::</span>

<span class="sd">        (fwd_expr &lt;&lt; a) | b | c</span>

<span class="sd">    thereby leaving b and c out as parseable alternatives.  It is recommended that you</span>
<span class="sd">    explicitly group the values inserted into the ``Forward``::</span>

<span class="sd">        fwd_expr &lt;&lt; (a | b | c)</span>

<span class="sd">    Converting to use the ``&#39;&lt;&lt;=&#39;`` operator instead will avoid this problem.</span>

<span class="sd">    See :class:`ParseResults.pprint` for an example of a recursive</span>
<span class="sd">    parser created using ``Forward``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">caller_frame</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lshift_line</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;caller_frame&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">caller_frame</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">str_type</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">other</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">mayIndexError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_whitespace_chars</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">whiteChars</span><span class="p">,</span> <span class="n">copy_defaults</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">skipWhitespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">saveAsList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lshift_line</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__ilshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&lt;&lt;</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">caller_line</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_on_match_first_with_lshift_operator</span>
            <span class="ow">and</span> <span class="n">caller_line</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lshift_line</span>
            <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_on_match_first_with_lshift_operator</span>
            <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span>
        <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;using &#39;&lt;&lt;&#39; operator with &#39;|&#39; is probably an error, use &#39;&lt;&lt;=&#39;&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__or__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># see if we are getting dropped because of &#39;=&#39; reassignment of var instead of &#39;&lt;&lt;=&#39; or &#39;&lt;&lt;&#39;</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_on_assignment_to_Forward</span>
            <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_on_assignment_to_Forward</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span>
        <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn_explicit</span><span class="p">(</span>
                <span class="s2">&quot;Forward defined here but no expression attached later using &#39;&lt;&lt;=&#39; or &#39;&lt;&lt;&#39;&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caller_frame</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                <span class="n">lineno</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">caller_frame</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_on_parse_using_empty_Forward</span>
            <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_on_parse_using_empty_Forward</span>
            <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span>
        <span class="p">):</span>
            <span class="c1"># walk stack until parse_string, scan_string, search_string, or transform_string is found</span>
            <span class="n">parse_fns</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;parse_string&quot;</span><span class="p">,</span>
                <span class="s2">&quot;scan_string&quot;</span><span class="p">,</span>
                <span class="s2">&quot;search_string&quot;</span><span class="p">,</span>
                <span class="s2">&quot;transform_string&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">tb</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">tb</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">frm</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">parse_fns</span><span class="p">:</span>
                    <span class="n">stacklevel</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stacklevel</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Forward expression was never assigned a value, will not parse any input&quot;</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="n">stacklevel</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_left_recursion_enabled</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
        <span class="c1"># ## Bounded Recursion algorithm ##</span>
        <span class="c1"># Recursion only needs to be processed at ``Forward`` elements, since they are</span>
        <span class="c1"># the only ones that can actually refer to themselves. The general idea is</span>
        <span class="c1"># to handle recursion stepwise: We start at no recursion, then recurse once,</span>
        <span class="c1"># recurse twice, ..., until more recursion offers no benefit (we hit the bound).</span>
        <span class="c1">#</span>
        <span class="c1"># The &quot;trick&quot; here is that each ``Forward`` gets evaluated in two contexts</span>
        <span class="c1"># - to *match* a specific recursion level, and</span>
        <span class="c1"># - to *search* the bounded recursion level</span>
        <span class="c1"># and the two run concurrently. The *search* must *match* each recursion level</span>
        <span class="c1"># to find the best possible match. This is handled by a memo table, which</span>
        <span class="c1"># provides the previous match to the next level match attempt.</span>
        <span class="c1">#</span>
        <span class="c1"># See also &quot;Left Recursion in Parsing Expression Grammars&quot;, Medeiros et al.</span>
        <span class="c1">#</span>
        <span class="c1"># There is a complication since we not only *parse* but also *transform* via</span>
        <span class="c1"># actions: We do not want to run the actions too often while expanding. Thus,</span>
        <span class="c1"># we expand using `doActions=False` and only run `doActions=True` if the next</span>
        <span class="c1"># recursion level is acceptable.</span>
        <span class="k">with</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">recursion_lock</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">recursion_memos</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># we are parsing at a specific recursion expansion - use it as-is</span>
                <span class="n">prev_loc</span><span class="p">,</span> <span class="n">prev_result</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">doActions</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prev_result</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">prev_result</span>
                <span class="k">return</span> <span class="n">prev_loc</span><span class="p">,</span> <span class="n">prev_result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">act_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">peek_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="c1"># we are searching for the best recursion expansion - keep on improving</span>
                <span class="c1"># both `doActions` cases must be tracked separately here!</span>
                <span class="n">prev_loc</span><span class="p">,</span> <span class="n">prev_peek</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">peek_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">ParseException</span><span class="p">(</span>
                        <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;Forward recursion without base case&quot;</span><span class="p">,</span> <span class="bp">self</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">doActions</span><span class="p">:</span>
                    <span class="n">memo</span><span class="p">[</span><span class="n">act_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">peek_key</span><span class="p">]</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">new_loc</span><span class="p">,</span> <span class="n">new_peek</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                        <span class="c1"># we failed before getting any match  do not hide the error</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prev_peek</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                            <span class="k">raise</span>
                        <span class="n">new_loc</span><span class="p">,</span> <span class="n">new_peek</span> <span class="o">=</span> <span class="n">prev_loc</span><span class="p">,</span> <span class="n">prev_peek</span>
                    <span class="c1"># the match did not get better: we are done</span>
                    <span class="k">if</span> <span class="n">new_loc</span> <span class="o">&lt;=</span> <span class="n">prev_loc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">doActions</span><span class="p">:</span>
                            <span class="c1"># replace the match for doActions=False as well,</span>
                            <span class="c1"># in case the action did backtrack</span>
                            <span class="n">prev_loc</span><span class="p">,</span> <span class="n">prev_result</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">peek_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">act_key</span><span class="p">]</span>
                            <span class="k">del</span> <span class="n">memo</span><span class="p">[</span><span class="n">peek_key</span><span class="p">],</span> <span class="n">memo</span><span class="p">[</span><span class="n">act_key</span><span class="p">]</span>
                            <span class="k">return</span> <span class="n">prev_loc</span><span class="p">,</span> <span class="n">prev_result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="k">del</span> <span class="n">memo</span><span class="p">[</span><span class="n">peek_key</span><span class="p">]</span>
                        <span class="k">return</span> <span class="n">prev_loc</span><span class="p">,</span> <span class="n">prev_peek</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="c1"># the match did get better: see if we can improve further</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">doActions</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">memo</span><span class="p">[</span><span class="n">act_key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                            <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                                <span class="n">memo</span><span class="p">[</span><span class="n">peek_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">act_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_loc</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                                <span class="k">raise</span>
                        <span class="n">prev_loc</span><span class="p">,</span> <span class="n">prev_peek</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="n">peek_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_loc</span><span class="p">,</span> <span class="n">new_peek</span>

    <span class="k">def</span> <span class="nf">leave_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">validateTrace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validateTrace</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">validateTrace</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">validateTrace</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkRecursion</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">_generateDefaultName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Avoid infinite recursion by setting a temporary _defaultName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_defaultName</span> <span class="o">=</span> <span class="s2">&quot;: ...&quot;</span>

        <span class="c1"># Use the string representation of main expression.</span>
        <span class="n">retString</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">retString</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)[:</span><span class="mi">1000</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retString</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">retString</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">_setResultsName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">list_all_matches</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">__diag__</span><span class="o">.</span><span class="n">warn_name_set_on_empty_Forward</span>
            <span class="ow">and</span> <span class="n">Diagnostics</span><span class="o">.</span><span class="n">warn_name_set_on_empty_Forward</span>
            <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">suppress_warnings_</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">: setting results name </span><span class="si">{!r}</span><span class="s2"> on </span><span class="si">{}</span><span class="s2"> expression &quot;</span>
                    <span class="s2">&quot;that has no contained expression&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="s2">&quot;warn_name_set_on_empty_Forward&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="p">),</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">list_all_matches</span><span class="p">)</span>

    <span class="n">ignoreWhitespace</span> <span class="o">=</span> <span class="n">ignore_whitespace</span>
    <span class="n">leaveWhitespace</span> <span class="o">=</span> <span class="n">leave_whitespace</span>


<span class="k">class</span> <span class="nc">TokenConverter</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract subclass of :class:`ParseExpression`, for converting parsed results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>  <span class="c1"># , savelist)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">Combine</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converter to concatenate all matching tokens to a single string.</span>
<span class="sd">    By default, the matching patterns must also be contiguous in the</span>
<span class="sd">    input string; this can be disabled by specifying</span>
<span class="sd">    ``&#39;adjacent=False&#39;`` in the constructor.</span>

<span class="sd">    Example::</span>

<span class="sd">        real = Word(nums) + &#39;.&#39; + Word(nums)</span>
<span class="sd">        print(real.parse_string(&#39;3.1416&#39;)) # -&gt; [&#39;3&#39;, &#39;.&#39;, &#39;1416&#39;]</span>
<span class="sd">        # will also erroneously match the following</span>
<span class="sd">        print(real.parse_string(&#39;3. 1416&#39;)) # -&gt; [&#39;3&#39;, &#39;.&#39;, &#39;1416&#39;]</span>

<span class="sd">        real = Combine(Word(nums) + &#39;.&#39; + Word(nums))</span>
<span class="sd">        print(real.parse_string(&#39;3.1416&#39;)) # -&gt; [&#39;3.1416&#39;]</span>
<span class="sd">        # no match when there are internal spaces</span>
<span class="sd">        print(real.parse_string(&#39;3. 1416&#39;)) # -&gt; Exception: Expected W:(0123...)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">expr</span><span class="p">:</span> <span class="n">ParserElement</span><span class="p">,</span>
        <span class="n">join_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">adjacent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">joinString</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">joinString</span> <span class="o">=</span> <span class="n">joinString</span> <span class="k">if</span> <span class="n">joinString</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">join_string</span>
        <span class="c1"># suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself</span>
        <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leave_whitespace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjacent</span> <span class="o">=</span> <span class="n">adjacent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">joinString</span> <span class="o">=</span> <span class="n">joinString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacent</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="n">retToks</span> <span class="o">=</span> <span class="n">tokenlist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">retToks</span><span class="p">[:]</span>
        <span class="n">retToks</span> <span class="o">+=</span> <span class="n">ParseResults</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokenlist</span><span class="o">.</span><span class="n">_asStringList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joinString</span><span class="p">))],</span> <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span> <span class="ow">and</span> <span class="n">retToks</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">retToks</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">retToks</span>


<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converter to return the matched tokens as a list - useful for</span>
<span class="sd">    returning tokens of :class:`ZeroOrMore` and :class:`OneOrMore` expressions.</span>

<span class="sd">    The optional ``aslist`` argument when set to True will return the</span>
<span class="sd">    parsed tokens as a Python list instead of a pyparsing ParseResults.</span>

<span class="sd">    Example::</span>

<span class="sd">        ident = Word(alphas)</span>
<span class="sd">        num = Word(nums)</span>
<span class="sd">        term = ident | num</span>
<span class="sd">        func = ident + Opt(delimited_list(term))</span>
<span class="sd">        print(func.parse_string(&quot;fn a, b, 100&quot;))</span>
<span class="sd">        # -&gt; [&#39;fn&#39;, &#39;a&#39;, &#39;b&#39;, &#39;100&#39;]</span>

<span class="sd">        func = ident + Group(Opt(delimited_list(term)))</span>
<span class="sd">        print(func.parse_string(&quot;fn a, b, 100&quot;))</span>
<span class="sd">        # -&gt; [&#39;fn&#39;, [&#39;a&#39;, &#39;b&#39;, &#39;100&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParserElement</span><span class="p">,</span> <span class="n">aslist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_asPythonList</span> <span class="o">=</span> <span class="n">aslist</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asPythonList</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ParseResults</span><span class="o">.</span><span class="n">List</span><span class="p">(</span>
                <span class="n">tokenlist</span><span class="o">.</span><span class="n">asList</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokenlist</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokenlist</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tokenlist</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Dict</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converter to return a repetitive expression as a list, but also</span>
<span class="sd">    as a dictionary. Each element can also be referenced using the first</span>
<span class="sd">    token in the expression as its key. Useful for tabular report</span>
<span class="sd">    scraping when the first column can be used as a item key.</span>

<span class="sd">    The optional ``asdict`` argument when set to True will return the</span>
<span class="sd">    parsed tokens as a Python dict instead of a pyparsing ParseResults.</span>

<span class="sd">    Example::</span>

<span class="sd">        data_word = Word(alphas)</span>
<span class="sd">        label = data_word + FollowedBy(&#39;:&#39;)</span>

<span class="sd">        text = &quot;shape: SQUARE posn: upper left color: light blue texture: burlap&quot;</span>
<span class="sd">        attr_expr = (label + Suppress(&#39;:&#39;) + OneOrMore(data_word, stop_on=label).set_parse_action(&#39; &#39;.join))</span>

<span class="sd">        # print attributes as plain groups</span>
<span class="sd">        print(attr_expr[1, ...].parse_string(text).dump())</span>

<span class="sd">        # instead of OneOrMore(expr), parse using Dict(Group(expr)[1, ...]) - Dict will auto-assign names</span>
<span class="sd">        result = Dict(Group(attr_expr)[1, ...]).parse_string(text)</span>
<span class="sd">        print(result.dump())</span>

<span class="sd">        # access named fields as dict entries, or output as dict</span>
<span class="sd">        print(result[&#39;shape&#39;])</span>
<span class="sd">        print(result.as_dict())</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;shape&#39;, &#39;SQUARE&#39;, &#39;posn&#39;, &#39;upper left&#39;, &#39;color&#39;, &#39;light blue&#39;, &#39;texture&#39;, &#39;burlap&#39;]</span>
<span class="sd">        [[&#39;shape&#39;, &#39;SQUARE&#39;], [&#39;posn&#39;, &#39;upper left&#39;], [&#39;color&#39;, &#39;light blue&#39;], [&#39;texture&#39;, &#39;burlap&#39;]]</span>
<span class="sd">        - color: &#39;light blue&#39;</span>
<span class="sd">        - posn: &#39;upper left&#39;</span>
<span class="sd">        - shape: &#39;SQUARE&#39;</span>
<span class="sd">        - texture: &#39;burlap&#39;</span>
<span class="sd">        SQUARE</span>
<span class="sd">        {&#39;color&#39;: &#39;light blue&#39;, &#39;posn&#39;: &#39;upper left&#39;, &#39;texture&#39;: &#39;burlap&#39;, &#39;shape&#39;: &#39;SQUARE&#39;}</span>

<span class="sd">    See more examples at :class:`ParseResults` of accessing fields by results name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">ParserElement</span><span class="p">,</span> <span class="n">asdict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_asPythonDict</span> <span class="o">=</span> <span class="n">asdict</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tok</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokenlist</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">ikey</span> <span class="o">=</span> <span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ikey</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">ikey</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ikey</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ParseResults</span><span class="p">):</span>
                <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dictvalue</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># ParseResults(i)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">exc</span> <span class="o">=</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;could not extract dict values from parsed results&quot;</span>
                        <span class="s2">&quot; - Dict expression must contain Grouped expressions&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">exc</span> <span class="kn">from</span> <span class="bp">None</span>

                <span class="k">del</span> <span class="n">dictvalue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dictvalue</span><span class="o">.</span><span class="n">haskeys</span><span class="p">()</span>
                <span class="p">):</span>
                    <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asPythonDict</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tokenlist</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span> <span class="k">else</span> <span class="n">tokenlist</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">tokenlist</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span> <span class="k">else</span> <span class="n">tokenlist</span>


<span class="k">class</span> <span class="nc">Suppress</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converter for ignoring the results of a parsed expression.</span>

<span class="sd">    Example::</span>

<span class="sd">        source = &quot;a, b, c,d&quot;</span>
<span class="sd">        wd = Word(alphas)</span>
<span class="sd">        wd_list1 = wd + (&#39;,&#39; + wd)[...]</span>
<span class="sd">        print(wd_list1.parse_string(source))</span>

<span class="sd">        # often, delimiters that are useful during parsing are just in the</span>
<span class="sd">        # way afterward - use Suppress to keep them out of the parsed output</span>
<span class="sd">        wd_list2 = wd + (Suppress(&#39;,&#39;) + wd)[...]</span>
<span class="sd">        print(wd_list2.parse_string(source))</span>

<span class="sd">        # Skipped text (using &#39;...&#39;) can be suppressed as well</span>
<span class="sd">        source = &quot;lead in START relevant text END trailing text&quot;</span>
<span class="sd">        start_marker = Keyword(&quot;START&quot;)</span>
<span class="sd">        end_marker = Keyword(&quot;END&quot;)</span>
<span class="sd">        find_body = Suppress(...) + start_marker + ... + end_marker</span>
<span class="sd">        print(find_body.parse_string(source)</span>

<span class="sd">    prints::</span>

<span class="sd">        [&#39;a&#39;, &#39;,&#39;, &#39;b&#39;, &#39;,&#39;, &#39;c&#39;, &#39;,&#39;, &#39;d&#39;]</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">        [&#39;START&#39;, &#39;relevant text &#39;, &#39;END&#39;]</span>

<span class="sd">    (See also :class:`delimited_list`.)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">savelist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">_PendingSkip</span><span class="p">(</span><span class="n">NoMatch</span><span class="p">())</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">_PendingSkip</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">SkipTo</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="o">+</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ParserElement&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">_PendingSkip</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">SkipTo</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__sub__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">suppress</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParserElement</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">def</span> <span class="nf">trace_parse_action</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">ParseAction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParseAction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator for debugging parse actions.</span>

<span class="sd">    When the parse action is called, this decorator will print</span>
<span class="sd">    ``&quot;&gt;&gt; entering method-name(line:&lt;current_source_line&gt;, &lt;parse_location&gt;, &lt;matched_tokens&gt;)&quot;``.</span>
<span class="sd">    When the parse action completes, the decorator will print</span>
<span class="sd">    ``&quot;&lt;&lt;&quot;`` followed by the returned value, or any exception that the parse action raised.</span>

<span class="sd">    Example::</span>

<span class="sd">        wd = Word(alphas)</span>

<span class="sd">        @trace_parse_action</span>
<span class="sd">        def remove_duplicate_chars(tokens):</span>
<span class="sd">            return &#39;&#39;.join(sorted(set(&#39;&#39;.join(tokens))))</span>

<span class="sd">        wds = wd[1, ...].set_parse_action(remove_duplicate_chars)</span>
<span class="sd">        print(wds.parse_string(&quot;slkdjs sld sldd sdlf sdljf&quot;))</span>

<span class="sd">    prints::</span>

<span class="sd">        &gt;&gt;entering remove_duplicate_chars(line: &#39;slkdjs sld sldd sdlf sdljf&#39;, 0, ([&#39;slkdjs&#39;, &#39;sld&#39;, &#39;sldd&#39;, &#39;sdlf&#39;, &#39;sdljf&#39;], {}))</span>
<span class="sd">        &lt;&lt;leaving remove_duplicate_chars (ret: &#39;dfjkls&#39;)</span>
<span class="sd">        [&#39;dfjkls&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">_trim_arity</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">z</span><span class="p">(</span><span class="o">*</span><span class="n">paArgs</span><span class="p">):</span>
        <span class="n">thisFunc</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">paArgs</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paArgs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">thisFunc</span> <span class="o">=</span> <span class="n">paArgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">thisFunc</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
            <span class="s2">&quot;&gt;&gt;entering </span><span class="si">{}</span><span class="s2">(line: </span><span class="si">{!r}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{!r}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thisFunc</span><span class="p">,</span> <span class="n">line</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">paArgs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;&lt;leaving </span><span class="si">{}</span><span class="s2"> (exception: </span><span class="si">{}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thisFunc</span><span class="p">,</span> <span class="n">exc</span><span class="p">))</span>
            <span class="k">raise</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&lt;&lt;leaving </span><span class="si">{}</span><span class="s2"> (ret: </span><span class="si">{!r}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thisFunc</span><span class="p">,</span> <span class="n">ret</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="n">z</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="n">z</span>


<span class="c1"># convenience constants for positional expressions</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;empty&quot;</span><span class="p">)</span>
<span class="n">line_start</span> <span class="o">=</span> <span class="n">LineStart</span><span class="p">()</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;line_start&quot;</span><span class="p">)</span>
<span class="n">line_end</span> <span class="o">=</span> <span class="n">LineEnd</span><span class="p">()</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;line_end&quot;</span><span class="p">)</span>
<span class="n">string_start</span> <span class="o">=</span> <span class="n">StringStart</span><span class="p">()</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;string_start&quot;</span><span class="p">)</span>
<span class="n">string_end</span> <span class="o">=</span> <span class="n">StringEnd</span><span class="p">()</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;string_end&quot;</span><span class="p">)</span>

<span class="n">_escapedPunc</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">_bslash</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\[]-*.$+^?()~ &quot;</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">set_parse_action</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">_escapedHexChar</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">0?[xX][0-9a-fA-F]+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_parse_action</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\0x&quot;</span><span class="p">),</span> <span class="mi">16</span><span class="p">))</span>
<span class="p">)</span>
<span class="n">_escapedOctChar</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">0[0-7]+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_parse_action</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">8</span><span class="p">))</span>
<span class="p">)</span>
<span class="n">_singleChar</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_escapedPunc</span> <span class="o">|</span> <span class="n">_escapedHexChar</span> <span class="o">|</span> <span class="n">_escapedOctChar</span> <span class="o">|</span> <span class="n">CharsNotIn</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\]&quot;</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">_charRange</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">_singleChar</span> <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">_singleChar</span><span class="p">)</span>
<span class="n">_reBracketExpr</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)</span>
    <span class="o">+</span> <span class="n">Opt</span><span class="p">(</span><span class="s2">&quot;^&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_results_name</span><span class="p">(</span><span class="s2">&quot;negate&quot;</span><span class="p">)</span>
    <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="n">_charRange</span> <span class="o">|</span> <span class="n">_singleChar</span><span class="p">))</span><span class="o">.</span><span class="n">set_results_name</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
    <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">srange</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Helper to easily define string ranges for use in :class:`Word`</span>
<span class="sd">    construction. Borrows syntax from regexp ``&#39;[]&#39;`` string range</span>
<span class="sd">    definitions::</span>

<span class="sd">        srange(&quot;[0-9]&quot;)   -&gt; &quot;0123456789&quot;</span>
<span class="sd">        srange(&quot;[a-z]&quot;)   -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="sd">        srange(&quot;[a-z$_]&quot;) -&gt; &quot;abcdefghijklmnopqrstuvwxyz$_&quot;</span>

<span class="sd">    The input string must be enclosed in []&#39;s, and the returned string</span>
<span class="sd">    is the expanded character set joined into a single string. The</span>
<span class="sd">    values enclosed in the []&#39;s may be:</span>

<span class="sd">    - a single character</span>
<span class="sd">    - an escaped character with a leading backslash (such as ``\-``</span>
<span class="sd">      or ``\]``)</span>
<span class="sd">    - an escaped hex character with a leading ``&#39;\x&#39;``</span>
<span class="sd">      (``\x21``, which is a ``&#39;!&#39;`` character) (``\0x##``</span>
<span class="sd">      is also supported for backwards compatibility)</span>
<span class="sd">    - an escaped octal character with a leading ``&#39;\0&#39;``</span>
<span class="sd">      (``\041``, which is a ``&#39;!&#39;`` character)</span>
<span class="sd">    - a range of any of the above, separated by a dash (``&#39;a-z&#39;``,</span>
<span class="sd">      etc.)</span>
<span class="sd">    - any combination of the above (``&#39;aeiouy&#39;``,</span>
<span class="sd">      ``&#39;a-zA-Z0-9_$&#39;``, etc.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_expanded</span> <span class="o">=</span> <span class="p">(</span>
        <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)</span>
        <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">ord</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_expanded</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">_reBracketExpr</span><span class="o">.</span><span class="n">parse_string</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>


<span class="k">def</span> <span class="nf">token_map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParseAction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper to define a parse action by mapping a function to all</span>
<span class="sd">    elements of a :class:`ParseResults` list. If any additional args are passed,</span>
<span class="sd">    they are forwarded to the given function as additional arguments</span>
<span class="sd">    after the token, as in</span>
<span class="sd">    ``hex_integer = Word(hexnums).set_parse_action(token_map(int, 16))``,</span>
<span class="sd">    which will convert the parsed data to an integer using base 16.</span>

<span class="sd">    Example (compare the last to example in :class:`ParserElement.transform_string`::</span>

<span class="sd">        hex_ints = Word(hexnums)[1, ...].set_parse_action(token_map(int, 16))</span>
<span class="sd">        hex_ints.run_tests(&#39;&#39;&#39;</span>
<span class="sd">            00 11 22 aa FF 0a 0d 1a</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">        upperword = Word(alphas).set_parse_action(token_map(str.upper))</span>
<span class="sd">        upperword[1, ...].run_tests(&#39;&#39;&#39;</span>
<span class="sd">            my kingdom for a horse</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">        wd = Word(alphas).set_parse_action(token_map(str.title))</span>
<span class="sd">        wd[1, ...].set_parse_action(&#39; &#39;.join).run_tests(&#39;&#39;&#39;</span>
<span class="sd">            now is the winter of our discontent made glorious summer by this sun of york</span>
<span class="sd">            &#39;&#39;&#39;)</span>

<span class="sd">    prints::</span>

<span class="sd">        00 11 22 aa FF 0a 0d 1a</span>
<span class="sd">        [0, 17, 34, 170, 255, 10, 13, 26]</span>

<span class="sd">        my kingdom for a horse</span>
<span class="sd">        [&#39;MY&#39;, &#39;KINGDOM&#39;, &#39;FOR&#39;, &#39;A&#39;, &#39;HORSE&#39;]</span>

<span class="sd">        now is the winter of our discontent made glorious summer by this sun of york</span>
<span class="sd">        [&#39;Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">tokn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">tokn</span> <span class="ow">in</span> <span class="n">t</span><span class="p">]</span>

    <span class="n">func_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__class__&quot;</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="n">pa</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">func_name</span>

    <span class="k">return</span> <span class="n">pa</span>


<span class="k">def</span> <span class="nf">autoname_elements</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility to simplify mass-naming of parser elements, for</span>
<span class="sd">    generating railroad diagram with named subdiagrams.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_back</span><span class="o">.</span><span class="n">f_locals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">var</span><span class="o">.</span><span class="n">customName</span><span class="p">:</span>
            <span class="n">var</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>


<span class="n">dbl_quoted_string</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span>
    <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&quot;(?:[^&quot;\n\r</span><span class="se">\\</span><span class="s1">]|(?:&quot;&quot;)|(?:</span><span class="se">\\</span><span class="s1">(?:[^x]|x[0-9a-fA-F]+)))*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span>
<span class="p">)</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;string enclosed in double quotes&quot;</span><span class="p">)</span>

<span class="n">sgl_quoted_string</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span>
    <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&#39;(?:[^&#39;\n\r</span><span class="se">\\</span><span class="s2">]|(?:&#39;&#39;)|(?:</span><span class="se">\\</span><span class="s2">(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
<span class="p">)</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;string enclosed in single quotes&quot;</span><span class="p">)</span>

<span class="n">quoted_string</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span>
    <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&quot;(?:[^&quot;\n\r</span><span class="se">\\</span><span class="s1">]|(?:&quot;&quot;)|(?:</span><span class="se">\\</span><span class="s1">(?:[^x]|x[0-9a-fA-F]+)))*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span>
    <span class="o">|</span> <span class="n">Regex</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&#39;(?:[^&#39;\n\r</span><span class="se">\\</span><span class="s2">]|(?:&#39;&#39;)|(?:</span><span class="se">\\</span><span class="s2">(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
<span class="p">)</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;quotedString using single or double quotes&quot;</span><span class="p">)</span>

<span class="n">unicode_string</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="s2">&quot;u&quot;</span> <span class="o">+</span> <span class="n">quoted_string</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s2">&quot;unicode string literal&quot;</span><span class="p">)</span>


<span class="n">alphas8bit</span> <span class="o">=</span> <span class="n">srange</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]&quot;</span><span class="p">)</span>
<span class="n">punc8bit</span> <span class="o">=</span> <span class="n">srange</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[\0xa1-\0xbf\0xd7\0xf7]&quot;</span><span class="p">)</span>

<span class="c1"># build list of built-in expressions, for future reference if a global default value</span>
<span class="c1"># gets updated</span>
<span class="n">_builtin_exprs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ParserElement</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">)</span>
<span class="p">]</span>

<span class="c1"># backward compatibility names</span>
<span class="n">tokenMap</span> <span class="o">=</span> <span class="n">token_map</span>
<span class="n">conditionAsParseAction</span> <span class="o">=</span> <span class="n">condition_as_parse_action</span>
<span class="n">nullDebugAction</span> <span class="o">=</span> <span class="n">null_debug_action</span>
<span class="n">sglQuotedString</span> <span class="o">=</span> <span class="n">sgl_quoted_string</span>
<span class="n">dblQuotedString</span> <span class="o">=</span> <span class="n">dbl_quoted_string</span>
<span class="n">quotedString</span> <span class="o">=</span> <span class="n">quoted_string</span>
<span class="n">unicodeString</span> <span class="o">=</span> <span class="n">unicode_string</span>
<span class="n">lineStart</span> <span class="o">=</span> <span class="n">line_start</span>
<span class="n">lineEnd</span> <span class="o">=</span> <span class="n">line_end</span>
<span class="n">stringStart</span> <span class="o">=</span> <span class="n">string_start</span>
<span class="n">stringEnd</span> <span class="o">=</span> <span class="n">string_end</span>
<span class="n">traceParseAction</span> <span class="o">=</span> <span class="n">trace_parse_action</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Maty Novk &amp; Jano Minr.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>