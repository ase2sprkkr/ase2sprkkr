

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scipy.interpolate._interpolate &mdash; ASE2SPRKKR  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/mods.css?v=26f6988d" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ASE2SPRKKR
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">How to use the package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../how-to-install.html">More about the package installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../philosophy.html">Philosophy of the package (for developers)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference external" href="_static/slides.pdf#http://">Hastily written ASE2SPRKKR slides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://ase2sprkkr.github.io/ase2sprkkr/">ASE2SPRKKR homepage</a></li>
<li class="toctree-l1"><a class="reference external" href="https://wiki.fysik.dtu.dk/ase/">ASE - atomic simulation environment</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ebert.cup.uni-muenchen.de/index.php/en/software-en/13-sprkkr">SPR-KKR</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/ase2sprkkr/ase2sprkkr">GitHub repository</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.org/project/ase2sprkkr">PyPI package</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.ebert.cup.uni-muenchen.de/index.php/en/repository/func-startdown/251/lang,en-gb/">SPR-KKR manual</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Class documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../auto/ase2sprkkr.html">ase2sprkkr</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ASE2SPRKKR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">scipy.interpolate._interpolate</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scipy.interpolate._interpolate</h1><div class="highlight"><pre>
<span></span><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;interp1d&#39;</span><span class="p">,</span> <span class="s1">&#39;interp2d&#39;</span><span class="p">,</span> <span class="s1">&#39;lagrange&#39;</span><span class="p">,</span> <span class="s1">&#39;PPoly&#39;</span><span class="p">,</span> <span class="s1">&#39;BPoly&#39;</span><span class="p">,</span> <span class="s1">&#39;NdPPoly&#39;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">prod</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">intp</span><span class="p">,</span> <span class="n">poly1d</span><span class="p">,</span> <span class="n">searchsorted</span>

<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">spec</span>
<span class="kn">from</span> <span class="nn">scipy._lib._util</span> <span class="kn">import</span> <span class="n">copy_if_needed</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">comb</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_fitpack_py</span>
<span class="kn">from</span> <span class="nn">._polyint</span> <span class="kn">import</span> <span class="n">_Interpolator1D</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_ppoly</span>
<span class="kn">from</span> <span class="nn">.interpnd</span> <span class="kn">import</span> <span class="n">_ndim_coords_from_arrays</span>
<span class="kn">from</span> <span class="nn">._bsplines</span> <span class="kn">import</span> <span class="n">make_interp_spline</span><span class="p">,</span> <span class="n">BSpline</span>


<span class="k">def</span> <span class="nf">lagrange</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a Lagrange interpolating polynomial.</span>

<span class="sd">    Given two 1-D arrays `x` and `w,` returns the Lagrange interpolating</span>
<span class="sd">    polynomial through the points ``(x, w)``.</span>

<span class="sd">    Warning: This implementation is numerically unstable. Do not expect to</span>
<span class="sd">    be able to use more than about 20 points even if they are chosen optimally.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        `x` represents the x-coordinates of a set of datapoints.</span>
<span class="sd">    w : array_like</span>
<span class="sd">        `w` represents the y-coordinates of a set of datapoints, i.e., f(`x`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lagrange : `numpy.poly1d` instance</span>
<span class="sd">        The Lagrange interpolating polynomial.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Interpolate :math:`f(x) = x^3` by 3 points.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import lagrange</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; y = x**3</span>
<span class="sd">    &gt;&gt;&gt; poly = lagrange(x, y)</span>

<span class="sd">    Since there are only 3 points, Lagrange polynomial has degree 2. Explicitly,</span>
<span class="sd">    it is given by</span>

<span class="sd">    .. math::</span>

<span class="sd">        \begin{aligned}</span>
<span class="sd">            L(x) &amp;= 1\times \frac{x (x - 2)}{-1} + 8\times \frac{x (x-1)}{2} \\</span>
<span class="sd">                 &amp;= x (-2 + 3x)</span>
<span class="sd">        \end{aligned}</span>

<span class="sd">    &gt;&gt;&gt; from numpy.polynomial.polynomial import Polynomial</span>
<span class="sd">    &gt;&gt;&gt; Polynomial(poly.coef[::-1]).coef</span>
<span class="sd">    array([ 0., -2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x_new = np.arange(0, 2.1, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; plt.scatter(x, y, label=&#39;data&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x_new, Polynomial(poly.coef[::-1])(x_new), label=&#39;Polynomial&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x_new, 3*x_new**2 - 2*x_new + 0*x_new,</span>
<span class="sd">    ...          label=r&quot;$3 x^2 - 2 x$&quot;, linestyle=&#39;-.&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">poly1d</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">poly1d</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">pt</span> <span class="o">*=</span> <span class="n">poly1d</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span><span class="o">/</span><span class="n">fac</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">pt</span>
    <span class="k">return</span> <span class="n">p</span>


<span class="c1"># !! Need to find argument for keeping initialize. If it isn&#39;t</span>
<span class="c1"># !! found, get rid of it!</span>


<span class="n">err_mesg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">`interp2d` has been removed in SciPy 1.14.0.</span>

<span class="s2">For legacy code, nearly bug-for-bug compatible replacements are</span>
<span class="s2">`RectBivariateSpline` on regular grids, and `bisplrep`/`bisplev` for</span>
<span class="s2">scattered 2D data.</span>

<span class="s2">In new code, for regular grids use `RegularGridInterpolator` instead.</span>
<span class="s2">For scattered data, prefer `LinearNDInterpolator` or</span>
<span class="s2">`CloughTocher2DInterpolator`.</span>

<span class="s2">For more details see</span>
<span class="s2">https://scipy.github.io/devdocs/tutorial/interpolate/interp_transition_guide.html</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">interp2d</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    interp2d(x, y, z, kind=&#39;linear&#39;, copy=True, bounds_error=False,</span>
<span class="sd">             fill_value=None)</span>

<span class="sd">    .. versionremoved:: 1.14.0</span>

<span class="sd">        `interp2d` has been removed in SciPy 1.14.0.</span>

<span class="sd">        For legacy code, nearly bug-for-bug compatible replacements are</span>
<span class="sd">        `RectBivariateSpline` on regular grids, and `bisplrep`/`bisplev` for</span>
<span class="sd">        scattered 2D data.</span>

<span class="sd">        In new code, for regular grids use `RegularGridInterpolator` instead.</span>
<span class="sd">        For scattered data, prefer `LinearNDInterpolator` or</span>
<span class="sd">        `CloughTocher2DInterpolator`.</span>

<span class="sd">        For more details see :ref:`interp-transition-guide`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">err_mesg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_broadcast_up_to</span><span class="p">(</span><span class="n">arr_from</span><span class="p">,</span> <span class="n">shape_to</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper to check that arr_from broadcasts up to shape_to&quot;&quot;&quot;</span>
    <span class="n">shape_from</span> <span class="o">=</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_to</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_from</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape_to</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape_from</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">t</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># all checks pass, do the upcasting that we need later</span>
            <span class="k">if</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">shape_to</span><span class="p">:</span>
                <span class="n">arr_from</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape_to</span><span class="p">,</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">arr_from</span>
            <span class="k">return</span> <span class="n">arr_from</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="c1"># at least one check failed</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> argument must be able to broadcast up &#39;</span>
                     <span class="sa">f</span><span class="s1">&#39;to shape </span><span class="si">{</span><span class="n">shape_to</span><span class="si">}</span><span class="s1"> but had shape </span><span class="si">{</span><span class="n">shape_from</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper to check if fill_value == &quot;extrapolate&quot; without warnings&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">fill_value</span> <span class="o">==</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">interp1d</span><span class="p">(</span><span class="n">_Interpolator1D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolate a 1-D function.</span>

<span class="sd">    .. legacy:: class</span>

<span class="sd">        For a guide to the intended replacements for `interp1d` see</span>
<span class="sd">        :ref:`tutorial-interpolate_1Dsection`.</span>

<span class="sd">    `x` and `y` are arrays of values used to approximate some function f:</span>
<span class="sd">    ``y = f(x)``. This class returns a function whose call method uses</span>
<span class="sd">    interpolation to find the value of new points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (npoints, ) array_like</span>
<span class="sd">        A 1-D array of real values.</span>
<span class="sd">    y : (..., npoints, ...) array_like</span>
<span class="sd">        A N-D array of real values. The length of `y` along the interpolation</span>
<span class="sd">        axis must be equal to the length of `x`. Use the ``axis`` parameter</span>
<span class="sd">        to select correct axis. Unlike other interpolators, the default</span>
<span class="sd">        interpolation axis is the last axis of `y`.</span>
<span class="sd">    kind : str or int, optional</span>
<span class="sd">        Specifies the kind of interpolation as a string or as an integer</span>
<span class="sd">        specifying the order of the spline interpolator to use.</span>
<span class="sd">        The string has to be one of &#39;linear&#39;, &#39;nearest&#39;, &#39;nearest-up&#39;, &#39;zero&#39;,</span>
<span class="sd">        &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;previous&#39;, or &#39;next&#39;. &#39;zero&#39;,</span>
<span class="sd">        &#39;slinear&#39;, &#39;quadratic&#39; and &#39;cubic&#39; refer to a spline interpolation of</span>
<span class="sd">        zeroth, first, second or third order; &#39;previous&#39; and &#39;next&#39; simply</span>
<span class="sd">        return the previous or next value of the point; &#39;nearest-up&#39; and</span>
<span class="sd">        &#39;nearest&#39; differ when interpolating half-integers (e.g. 0.5, 1.5)</span>
<span class="sd">        in that &#39;nearest-up&#39; rounds up and &#39;nearest&#39; rounds down. Default</span>
<span class="sd">        is &#39;linear&#39;.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis in the ``y`` array corresponding to the x-coordinate values. Unlike</span>
<span class="sd">        other interpolators, defaults to ``axis=-1``.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If ``True``, the class makes internal copies of x and y. If ``False``,</span>
<span class="sd">        references to ``x`` and ``y`` are used if possible. The default is to copy.</span>
<span class="sd">    bounds_error : bool, optional</span>
<span class="sd">        If True, a ValueError is raised any time interpolation is attempted on</span>
<span class="sd">        a value outside of the range of x (where extrapolation is</span>
<span class="sd">        necessary). If False, out of bounds values are assigned `fill_value`.</span>
<span class="sd">        By default, an error is raised unless ``fill_value=&quot;extrapolate&quot;``.</span>
<span class="sd">    fill_value : array-like or (array-like, array_like) or &quot;extrapolate&quot;, optional</span>
<span class="sd">        - if a ndarray (or float), this value will be used to fill in for</span>
<span class="sd">          requested points outside of the data range. If not provided, then</span>
<span class="sd">          the default is NaN. The array-like must broadcast properly to the</span>
<span class="sd">          dimensions of the non-interpolation axes.</span>
<span class="sd">        - If a two-element tuple, then the first element is used as a</span>
<span class="sd">          fill value for ``x_new &lt; x[0]`` and the second element is used for</span>
<span class="sd">          ``x_new &gt; x[-1]``. Anything that is not a 2-element tuple (e.g.,</span>
<span class="sd">          list or ndarray, regardless of shape) is taken to be a single</span>
<span class="sd">          array-like argument meant to be used for both bounds as</span>
<span class="sd">          ``below, above = fill_value, fill_value``. Using a two-element tuple</span>
<span class="sd">          or ndarray requires ``bounds_error=False``.</span>

<span class="sd">          .. versionadded:: 0.17.0</span>
<span class="sd">        - If &quot;extrapolate&quot;, then points outside the data range will be</span>
<span class="sd">          extrapolated.</span>

<span class="sd">          .. versionadded:: 0.17.0</span>
<span class="sd">    assume_sorted : bool, optional</span>
<span class="sd">        If False, values of `x` can be in any order and they are sorted first.</span>
<span class="sd">        If True, `x` has to be an array of monotonically increasing values.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    fill_value</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    splrep, splev</span>
<span class="sd">        Spline interpolation/smoothing based on FITPACK.</span>
<span class="sd">    UnivariateSpline : An object-oriented wrapper of the FITPACK routines.</span>
<span class="sd">    interp2d : 2-D interpolation</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Calling `interp1d` with NaNs present in input values results in</span>
<span class="sd">    undefined behaviour.</span>

<span class="sd">    Input values `x` and `y` must be convertible to `float` values like</span>
<span class="sd">    `int` or `float`.</span>

<span class="sd">    If the values in `x` are not unique, the resulting behavior is</span>
<span class="sd">    undefined and specific to the choice of `kind`, i.e., changing</span>
<span class="sd">    `kind` will change the behavior for duplicates.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from scipy import interpolate</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(0, 10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.exp(-x/3.0)</span>
<span class="sd">    &gt;&gt;&gt; f = interpolate.interp1d(x, y)</span>

<span class="sd">    &gt;&gt;&gt; xnew = np.arange(0, 9, 0.1)</span>
<span class="sd">    &gt;&gt;&gt; ynew = f(xnew)   # use interpolation function returned by `interp1d`</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;, xnew, ynew, &#39;-&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                 <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initialize a 1-D linear interpolation class.&quot;&quot;&quot;</span>
        <span class="n">_Interpolator1D</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="n">bounds_error</span>  <span class="c1"># used by fill_value setter</span>

        <span class="c1"># `copy` keyword semantics changed in NumPy 2.0, once that is</span>
        <span class="c1"># the minimum version this can use `copy=None`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span> <span class="o">=</span> <span class="n">copy</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">copy</span> <span class="o">=</span> <span class="n">copy_if_needed</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="s1">&#39;slinear&#39;</span><span class="p">,</span> <span class="s1">&#39;quadratic&#39;</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">]:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;zero&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;slinear&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="s1">&#39;quadratic&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;cubic&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}[</span><span class="n">kind</span><span class="p">]</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;spline&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">kind</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;spline&#39;</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest-up&#39;</span><span class="p">,</span> <span class="s1">&#39;previous&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;next&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is unsupported: Use fitpack &quot;</span>
                                      <span class="s2">&quot;routines for other types.&quot;</span> <span class="o">%</span> <span class="n">kind</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_sorted</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;mergesort&quot;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the x array must have exactly one dimension.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the y array must have at least one dimension.&quot;</span><span class="p">)</span>

        <span class="c1"># Force-cast y to a floating-point type, if it&#39;s not yet one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Backward compatibility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span>

        <span class="c1"># Interpolation goes internally along the first axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_yi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">del</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>  <span class="c1"># clean up namespace to prevent misuse; use attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kind</span> <span class="o">=</span> <span class="n">kind</span>

        <span class="c1"># Adjust to interpolation kind; store reference to *unbound*</span>
        <span class="c1"># interpolation methods, in order to avoid circular references to self</span>
        <span class="c1"># stored in the bound instance methods, and therefore delayed garbage</span>
        <span class="c1"># collection.  See: https://docs.python.org/reference/datamodel.html</span>
        <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="s1">&#39;nearest-up&#39;</span><span class="p">,</span> <span class="s1">&#39;previous&#39;</span><span class="p">,</span> <span class="s1">&#39;next&#39;</span><span class="p">):</span>
            <span class="c1"># Make a &quot;view&quot; of the y array that is rotated to the interpolation</span>
            <span class="c1"># axis.</span>
            <span class="n">minval</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
                <span class="c1"># Do division before addition to prevent possible integer</span>
                <span class="c1"># overflow</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_side</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_nearest</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;nearest-up&#39;</span><span class="p">:</span>
                <span class="c1"># Do division before addition to prevent possible integer</span>
                <span class="c1"># overflow</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_nearest</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;previous&#39;</span><span class="p">:</span>
                <span class="c1"># Side for np.searchsorted and index for clipping</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_side</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Move x by one floating point value to the left</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_previousnext</span>
                <span class="k">if</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_and_update_bounds_error_for_extrapolation</span><span class="p">()</span>
                    <span class="c1"># assume y is sorted by x ascending order here.</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;next&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ind</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># Move x by one floating point value to the right</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_x_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nextafter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_previousnext</span>
                <span class="k">if</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check_and_update_bounds_error_for_extrapolation</span><span class="p">()</span>
                    <span class="c1"># assume y is sorted by x ascending order here.</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if we can delegate to numpy.interp (2x-10x faster).</span>
                <span class="n">np_dtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">np_dtypes</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">np_dtypes</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_linear_np</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_linear</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minval</span> <span class="o">=</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">rewrite_nan</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Quadratic or cubic spline. If input contains even a single</span>
                <span class="c1"># nan, then the output is all nans. We cannot just feed data</span>
                <span class="c1"># with nans to make_interp_spline because it calls LAPACK.</span>
                <span class="c1"># So, we make up a bogus x and y with no nans and use it</span>
                <span class="c1"># to get the correct shape of the output, which we then fill</span>
                <span class="c1"># with nans.</span>
                <span class="c1"># For slinear or zero order spline, we just pass nans through.</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">sx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">sx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` array is all-nan&quot;</span><span class="p">)</span>
                    <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">),</span>
                                     <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
                    <span class="n">rewrite_nan</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>
                    <span class="n">rewrite_nan</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span> <span class="o">=</span> <span class="n">make_interp_spline</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                                              <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rewrite_nan</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_nan_spline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_call_spline</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minval</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y arrays must have at &quot;</span>
                             <span class="s2">&quot;least </span><span class="si">%d</span><span class="s2"> entries&quot;</span> <span class="o">%</span> <span class="n">minval</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>  <span class="c1"># calls the setter, can modify bounds_err</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The fill value.&quot;&quot;&quot;</span>
        <span class="c1"># backwards compat: mimic a public attribute</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_orig</span>

    <span class="nd">@fill_value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
        <span class="c1"># extrapolation only works for nearest neighbor and linear methods</span>
        <span class="k">if</span> <span class="n">_do_extrapolate</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_and_update_bounds_error_for_extrapolation</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
            <span class="c1"># it&#39;s either a pair (_below_range, _above_range) or a single value</span>
            <span class="c1"># for both above and below range</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">below_above</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;fill_value (below)&#39;</span><span class="p">,</span> <span class="s1">&#39;fill_value (above)&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">below_above</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">_check_broadcast_up_to</span><span class="p">(</span>
                        <span class="n">below_above</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
                <span class="n">below_above</span> <span class="o">=</span> <span class="p">[</span><span class="n">_check_broadcast_up_to</span><span class="p">(</span>
                    <span class="n">fill_value</span><span class="p">,</span> <span class="n">broadcast_shape</span><span class="p">,</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_below</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_above</span> <span class="o">=</span> <span class="n">below_above</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># backwards compat: fill_value was a public attr; make it writeable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_orig</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="k">def</span> <span class="nf">_check_and_update_bounds_error_for_extrapolation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot extrapolate and raise &quot;</span>
                             <span class="s2">&quot;at the same time.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_call_linear_np</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="c1"># Note that out-of-bounds values are taken care of in self._evaluate</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">x_new</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="c1"># 2. Find where in the original data, the values to interpolate</span>
        <span class="c1">#    would be inserted.</span>
        <span class="c1">#    Note: If x_new[n] == x[m], then m is returned by searchsorted.</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_new</span><span class="p">)</span>

        <span class="c1"># 3. Clip x_new_indices so that they are within the range of</span>
        <span class="c1">#    self.x indices and at least 1. Removes mis-interpolation</span>
        <span class="c1">#    of x_new[n] = x[0]</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">x_new_indices</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># 4. Calculate the slope of regions that each x_new value falls in.</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">x_new_indices</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="n">x_new_indices</span>

        <span class="n">x_lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span>
        <span class="n">x_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span>
        <span class="n">y_lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span>
        <span class="n">y_hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span>

        <span class="c1"># Note that the following two expressions rely on the specifics of the</span>
        <span class="c1"># broadcasting semantics.</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_hi</span> <span class="o">-</span> <span class="n">y_lo</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x_hi</span> <span class="o">-</span> <span class="n">x_lo</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># 5. Calculate the actual value for each entry in x_new.</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="n">slope</span><span class="o">*</span><span class="p">(</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x_lo</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_lo</span>

        <span class="k">return</span> <span class="n">y_new</span>

    <span class="k">def</span> <span class="nf">_call_nearest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Find nearest neighbor interpolated y_new = f(x_new).&quot;&quot;&quot;</span>

        <span class="c1"># 2. Find where in the averaged data the values to interpolate</span>
        <span class="c1">#    would be inserted.</span>
        <span class="c1">#    Note: use side=&#39;left&#39; (right) to searchsorted() to define the</span>
        <span class="c1">#    halfway point to be nearest to the left (right) neighbor</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_bds</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_side</span><span class="p">)</span>

        <span class="c1"># 3. Clip x_new_indices so that they are within the range of x indices.</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">x_new_indices</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>

        <span class="c1"># 4. Calculate the actual value for each entry in x_new.</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">x_new_indices</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y_new</span>

    <span class="k">def</span> <span class="nf">_call_previousnext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use previous/next neighbor of x_new, y_new = f(x_new).&quot;&quot;&quot;</span>

        <span class="c1"># 1. Get index of left/right value</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_shift</span><span class="p">,</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_side</span><span class="p">)</span>

        <span class="c1"># 2. Clip x_new_indices so that they are within the range of x indices.</span>
        <span class="n">x_new_indices</span> <span class="o">=</span> <span class="n">x_new_indices</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_ind</span><span class="p">,</span>
                                           <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_ind</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>

        <span class="c1"># 3. Calculate the actual value for each entry in x_new.</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">[</span><span class="n">x_new_indices</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_ind</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">y_new</span>

    <span class="k">def</span> <span class="nf">_call_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_nan_spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spline</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
        <span class="c1"># 1. Handle values in x_new that are outside of x. Throw error,</span>
        <span class="c1">#    or return a list of mask array indicating the outofbounds values.</span>
        <span class="c1">#    The behavior is set by the bounds_error variable.</span>
        <span class="n">x_new</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
        <span class="n">y_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extrapolate</span><span class="p">:</span>
            <span class="n">below_bounds</span><span class="p">,</span> <span class="n">above_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_bounds</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_new</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Note fill_value must be broadcast up to the proper size</span>
                <span class="c1"># and flattened to work here</span>
                <span class="n">y_new</span><span class="p">[</span><span class="n">below_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_below</span>
                <span class="n">y_new</span><span class="p">[</span><span class="n">above_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value_above</span>
        <span class="k">return</span> <span class="n">y_new</span>

    <span class="k">def</span> <span class="nf">_check_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check the inputs for being in the bounds of the interpolated data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_new : array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out_of_bounds : bool array</span>
<span class="sd">            The mask on x_new of values that are out of the bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If self.bounds_error is True, we raise an error if any x_new values</span>
        <span class="c1"># fall outside the range of x. Otherwise, we return an array indicating</span>
        <span class="c1"># which values are outside the boundary region.</span>
        <span class="n">below_bounds</span> <span class="o">=</span> <span class="n">x_new</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">above_bounds</span> <span class="o">=</span> <span class="n">x_new</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="n">below_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">below_bounds_value</span> <span class="o">=</span> <span class="n">x_new</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">below_bounds</span><span class="p">)]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A value (</span><span class="si">{</span><span class="n">below_bounds_value</span><span class="si">}</span><span class="s2">) in x_new is below &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;the interpolation range&#39;s minimum value (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_error</span> <span class="ow">and</span> <span class="n">above_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">above_bounds_value</span> <span class="o">=</span> <span class="n">x_new</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">above_bounds</span><span class="p">)]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;A value (</span><span class="si">{</span><span class="n">above_bounds_value</span><span class="si">}</span><span class="s2">) in x_new is above &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;the interpolation range&#39;s maximum value (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="c1"># !! Should we emit a warning if some values are out of bounds?</span>
        <span class="c1"># !! matlab does not.</span>
        <span class="k">return</span> <span class="n">below_bounds</span><span class="p">,</span> <span class="n">above_bounds</span>


<span class="k">class</span> <span class="nc">_PPolyBase</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for piecewise polynomials.&quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">extrapolate</span> <span class="o">!=</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Coefficients array must be at least &quot;</span>
                             <span class="s2">&quot;2-dimensional.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis=</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> must be between 0 and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># move the interpolation axis to be the first one in self.c</span>
            <span class="c1"># More specifically, the target shape for self.c is (k, m, ...),</span>
            <span class="c1"># and axis !=0 means that we have c.shape (..., k, m, ...)</span>
            <span class="c1">#                                               ^</span>
            <span class="c1">#                                              axis</span>
            <span class="c1"># So we roll two of them.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be 1-dimensional&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least 2 breakpoints are needed&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;c must have at least 2 dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;polynomial must be at least of order 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of coefficients != len(x)-1&quot;</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` must be strictly increasing or decreasing.&quot;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> \
               <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">construct_fast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the piecewise polynomial without making checks.</span>

<span class="sd">        Takes the same parameters as the constructor. Input arguments</span>
<span class="sd">        ``c`` and ``x`` must be arrays of the correct shape and type. The</span>
<span class="sd">        ``c`` array can only be of dtypes float and complex, and ``x``</span>
<span class="sd">        array must have dtype float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_ensure_c_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        c and x may be modified by the user. The Cython code expects</span>
<span class="sd">        that they are C contiguous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add additional breakpoints and coefficients to the polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : ndarray, size (k, m, ...)</span>
<span class="sd">            Additional coefficients for polynomials in intervals. Note that</span>
<span class="sd">            the first additional interval will be formed using one of the</span>
<span class="sd">            ``self.x`` end points.</span>
<span class="sd">        x : ndarray, size (m,)</span>
<span class="sd">            Additional breakpoints. Must be sorted in the same order as</span>
<span class="sd">            ``self.x`` and either to the right or to the left of the current</span>
<span class="sd">            breakpoints.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid dimensions for c&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid dimensions for x&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shapes of x </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and c </span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> are incompatible&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="ow">or</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Shapes of c </span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and self.c </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> are incompatible&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dx</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is not sorted.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is in the different order &quot;</span>
                                 <span class="s2">&quot;than `self.x`.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;append&#39;</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;prepend&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is neither on the left or on the right &quot;</span>
                                 <span class="s2">&quot;from `self.x`.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is in the different order &quot;</span>
                                 <span class="s2">&quot;than `self.x`.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;append&#39;</span>
            <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="s1">&#39;prepend&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`x` is neither on the left or on the right &quot;</span>
                                 <span class="s2">&quot;from `self.x`.&quot;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dtype</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">k2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
                      <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;append&#39;</span><span class="p">:</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;prepend&#39;</span><span class="p">:</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="p">:</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">c2</span><span class="p">[</span><span class="n">k2</span><span class="o">-</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:,</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c2</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the piecewise polynomial or its derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array_like</span>
<span class="sd">            Points to evaluate the interpolant at.</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Must be non-negative.</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used.</span>
<span class="sd">            If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : array_like</span>
<span class="sd">            Interpolated values. Shape is determined by replacing</span>
<span class="sd">            the interpolation axis in the original array with the shape of x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals are considered half-open,</span>
<span class="sd">        ``[a, b)``, except for the last interval which is closed</span>
<span class="sd">        ``[a, b]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x_shape</span><span class="p">,</span> <span class="n">x_ndim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># With periodic extrapolation we map x to the segment</span>
        <span class="c1"># [self.x[0], self.x[-1]].</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># transpose to move the calculated values to the interpolation axis</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">x_ndim</span><span class="p">:</span><span class="n">x_ndim</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[:</span><span class="n">x_ndim</span><span class="p">]</span> <span class="o">+</span> <span class="n">l</span><span class="p">[</span><span class="n">x_ndim</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">:]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>


<span class="k">class</span> <span class="nc">PPoly</span><span class="p">(</span><span class="n">_PPolyBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Piecewise polynomial in terms of coefficients and breakpoints</span>

<span class="sd">    The polynomial between ``x[i]`` and ``x[i + 1]`` is written in the</span>
<span class="sd">    local power basis::</span>

<span class="sd">        S = sum(c[m, i] * (xp - x[i])**(k-m) for m in range(k+1))</span>

<span class="sd">    where ``k`` is the degree of the polynomial.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : ndarray, shape (k, m, ...)</span>
<span class="sd">        Polynomial coefficients, order `k` and `m` intervals.</span>
<span class="sd">    x : ndarray, shape (m+1,)</span>
<span class="sd">        Polynomial breakpoints. Must be sorted in either increasing or</span>
<span class="sd">        decreasing order.</span>
<span class="sd">    extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">        If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">        based on first and last intervals, or to return NaNs. If &#39;periodic&#39;,</span>
<span class="sd">        periodic extrapolation is used. Default is True.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Interpolation axis. Default is zero.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Breakpoints.</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Coefficients of the polynomials. They are reshaped</span>
<span class="sd">        to a 3-D array with the last dimension representing</span>
<span class="sd">        the trailing dimensions of the original coefficient array.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Interpolation axis.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>
<span class="sd">    derivative</span>
<span class="sd">    antiderivative</span>
<span class="sd">    integrate</span>
<span class="sd">    solve</span>
<span class="sd">    roots</span>
<span class="sd">    extend</span>
<span class="sd">    from_spline</span>
<span class="sd">    from_bernstein_basis</span>
<span class="sd">    construct_fast</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    BPoly : piecewise polynomials in the Bernstein basis</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    High-order polynomials in the power basis can be numerically</span>
<span class="sd">    unstable. Precision problems can start to appear for orders</span>
<span class="sd">    larger than 20-30.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Default is 1, i.e., compute the</span>
<span class="sd">            first derivative. If negative, the antiderivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            Piecewise polynomial of order k2 = k - n representing the derivative</span>
<span class="sd">            of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals are considered half-open,</span>
<span class="sd">        ``[a, b)``, except for the last interval which is closed</span>
<span class="sd">        ``[a, b]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="c1"># reduce order</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># derivative of order 0 is zero</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># multiply by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># construct a compatible polynomial</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the antiderivative.</span>

<span class="sd">        Antiderivative is also the indefinite integral of the function,</span>
<span class="sd">        and derivative is its inverse operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of antiderivative to evaluate. Default is 1, i.e., compute</span>
<span class="sd">            the first integral. If negative, the derivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            Piecewise polynomial of order k2 = k + n representing</span>
<span class="sd">            the antiderivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The antiderivative returned by this function is continuous and</span>
<span class="sd">        continuously differentiable to order n-1, up to floating point</span>
<span class="sd">        rounding error.</span>

<span class="sd">        If antiderivative is computed and ``self.extrapolate=&#39;periodic&#39;``,</span>
<span class="sd">        it will be set to False for the returned instance. This is done because</span>
<span class="sd">        the antiderivative is no longer periodic and its correct evaluation</span>
<span class="sd">        outside of the initially given x interval is difficult.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>

        <span class="c1"># divide by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">c</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">/=</span> <span class="n">factor</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># fix continuity of added degrees of freedom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">fix_continuity</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">nu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="c1"># construct a compatible polynomial</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a definite integral over a piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : float</span>
<span class="sd">            Lower integration bound</span>
<span class="sd">        b : float</span>
<span class="sd">            Upper integration bound</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used.</span>
<span class="sd">            If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ig : array_like</span>
<span class="sd">            Definite integral of the piecewise polynomial over [a, b]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="c1"># Swap integration bounds if needed</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">range_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="c1"># Compute the integral.</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="c1"># Split the integral into the part over period (can be several</span>
            <span class="c1"># of them) and the remaining part.</span>

            <span class="n">xs</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">xe</span> <span class="o">-</span> <span class="n">xs</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
            <span class="n">n_periods</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">range_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">*=</span> <span class="n">n_periods</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">range_int</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Map a to [xs, xe], b is always a + left.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">xs</span><span class="p">)</span> <span class="o">%</span> <span class="n">period</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">left</span>

            <span class="c1"># If b &lt;= xe then we need to integrate over [a, b], otherwise</span>
            <span class="c1"># over [a, xe] and from xs to what is remained.</span>
            <span class="n">remainder_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">range_int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">xe</span><span class="p">:</span>
                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">remainder_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">+=</span> <span class="n">remainder_int</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">xe</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">remainder_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">+=</span> <span class="n">remainder_int</span>

                <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">a</span> <span class="o">-</span> <span class="n">xe</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">remainder_int</span><span class="p">)</span>
                <span class="n">range_int</span> <span class="o">+=</span> <span class="n">remainder_int</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_ppoly</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">range_int</span><span class="p">)</span>

        <span class="c1"># Return</span>
        <span class="n">range_int</span> <span class="o">*=</span> <span class="n">sign</span>
        <span class="k">return</span> <span class="n">range_int</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">discontinuity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find real solutions of the equation ``pp(x) == y``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : float, optional</span>
<span class="sd">            Right-hand side. Default is zero.</span>
<span class="sd">        discontinuity : bool, optional</span>
<span class="sd">            Whether to report sign changes across discontinuities at</span>
<span class="sd">            breakpoints as roots.</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to return roots from the polynomial</span>
<span class="sd">            extrapolated based on first and last intervals, &#39;periodic&#39; works</span>
<span class="sd">            the same as False. If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        roots : ndarray</span>
<span class="sd">            Roots of the polynomial(s).</span>

<span class="sd">            If the PPoly object describes multiple polynomials, the</span>
<span class="sd">            return value is an object array whose each element is an</span>
<span class="sd">            ndarray containing the roots.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine works only on real-valued polynomials.</span>

<span class="sd">        If the piecewise polynomial contains sections that are</span>
<span class="sd">        identically zero, the root list will contain the start point</span>
<span class="sd">        of the corresponding interval, followed by a ``nan`` value.</span>

<span class="sd">        If the polynomial is discontinuous across a breakpoint, and</span>
<span class="sd">        there is a sign change across the breakpoint, this is reported</span>
<span class="sd">        if the `discont` parameter is True.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Finding roots of ``[x**2 - 1, (x - 1)**2]`` defined on intervals</span>
<span class="sd">        ``[-2, 1], [1, 2]``:</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import PPoly</span>
<span class="sd">        &gt;&gt;&gt; pp = PPoly(np.array([[1, -4, 3], [1, 0, 0]]).T, [-2, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; pp.solve()</span>
<span class="sd">        array([-1.,  1.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Root finding is only for &quot;</span>
                             <span class="s2">&quot;real-valued polynomials&quot;</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_ppoly</span><span class="o">.</span><span class="n">real_roots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">discontinuity</span><span class="p">),</span>
                              <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="c1"># this for-loop is equivalent to ``r2[...] = r``, but that&#39;s broken</span>
            <span class="c1"># in NumPy 1.6.0</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">root</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>

            <span class="k">return</span> <span class="n">r2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">discontinuity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find real roots of the piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        discontinuity : bool, optional</span>
<span class="sd">            Whether to report sign changes across discontinuities at</span>
<span class="sd">            breakpoints as roots.</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            If bool, determines whether to return roots from the polynomial</span>
<span class="sd">            extrapolated based on first and last intervals, &#39;periodic&#39; works</span>
<span class="sd">            the same as False. If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        roots : ndarray</span>
<span class="sd">            Roots of the polynomial(s).</span>

<span class="sd">            If the PPoly object describes multiple polynomials, the</span>
<span class="sd">            return value is an object array whose each element is an</span>
<span class="sd">            ndarray containing the roots.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        PPoly.solve</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">discontinuity</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_spline</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tck</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a piecewise polynomial from a spline</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tck</span>
<span class="sd">            A spline, as returned by `splrep` or a BSpline object.</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Construct an interpolating spline and convert it to a `PPoly` instance </span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import splrep, PPoly</span>
<span class="sd">        &gt;&gt;&gt; x = np.linspace(0, 1, 11)</span>
<span class="sd">        &gt;&gt;&gt; y = np.sin(2*np.pi*x)</span>
<span class="sd">        &gt;&gt;&gt; tck = splrep(x, y, s=0)</span>
<span class="sd">        &gt;&gt;&gt; p = PPoly.from_spline(tck)</span>
<span class="sd">        &gt;&gt;&gt; isinstance(p, PPoly)</span>
<span class="sd">        True</span>

<span class="sd">        Note that this function only supports 1D splines out of the box.</span>

<span class="sd">        If the ``tck`` object represents a parametric spline (e.g. constructed</span>
<span class="sd">        by `splprep` or a `BSpline` with ``c.ndim &gt; 1``), you will need to loop</span>
<span class="sd">        over the dimensions manually.</span>

<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import splprep, splev</span>
<span class="sd">        &gt;&gt;&gt; t = np.linspace(0, 1, 11)</span>
<span class="sd">        &gt;&gt;&gt; x = np.sin(2*np.pi*t)</span>
<span class="sd">        &gt;&gt;&gt; y = np.cos(2*np.pi*t)</span>
<span class="sd">        &gt;&gt;&gt; (t, c, k), u = splprep([x, y], s=0)</span>

<span class="sd">        Note that ``c`` is a list of two arrays of length 11.</span>

<span class="sd">        &gt;&gt;&gt; unew = np.arange(0, 1.01, 0.01)</span>
<span class="sd">        &gt;&gt;&gt; out = splev(unew, (t, c, k))</span>

<span class="sd">        To convert this spline to the power basis, we convert each</span>
<span class="sd">        component of the list of b-spline coefficients, ``c``, into the</span>
<span class="sd">        corresponding cubic polynomial.</span>

<span class="sd">        &gt;&gt;&gt; polys = [PPoly.from_spline((t, cj, k)) for cj in c]</span>
<span class="sd">        &gt;&gt;&gt; polys[0].c.shape</span>
<span class="sd">        (4, 14)</span>

<span class="sd">        Note that the coefficients of the polynomials `polys` are in the</span>
<span class="sd">        power basis and their dimensions reflect just that: here 4 is the order</span>
<span class="sd">        (degree+1), and 14 is the number of intervals---which is nothing but</span>
<span class="sd">        the length of the knot array of the original `tck` minus one.</span>

<span class="sd">        Optionally, we can stack the components into a single `PPoly` along</span>
<span class="sd">        the third dimension:</span>

<span class="sd">        &gt;&gt;&gt; cc = np.dstack([p.c for p in polys])    # has shape = (4, 14, 2)</span>
<span class="sd">        &gt;&gt;&gt; poly = PPoly(cc, polys[0].x)</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(poly(unew).T,     # note the transpose to match `splev`</span>
<span class="sd">        ...             out, atol=1e-15)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tck</span><span class="p">,</span> <span class="n">BSpline</span><span class="p">):</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tck</span><span class="o">.</span><span class="n">tck</span>
            <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">extrapolate</span> <span class="o">=</span> <span class="n">tck</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">tck</span>

        <span class="n">cvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">_fitpack_py</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tck</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="n">cvals</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="o">/</span><span class="n">spec</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">cvals</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_bernstein_basis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a piecewise polynomial in the power basis</span>
<span class="sd">        from a polynomial in Bernstein basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bp : BPoly</span>
<span class="sd">            A Bernstein basis polynomial, as created by BPoly</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">BPoly</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;.from_bernstein_basis only accepts BPoly instances. &quot;</span>
                            <span class="s2">&quot;Got </span><span class="si">%s</span><span class="s2"> instead.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># polynomial order</span>

        <span class="n">rest</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">a</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">bp</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">s</span>
                <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">val</span> <span class="o">/</span> <span class="n">dx</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">+</span><span class="n">rest</span><span class="p">]</span><span class="o">**</span><span class="n">s</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bp</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">bp</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BPoly</span><span class="p">(</span><span class="n">_PPolyBase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Piecewise polynomial in terms of coefficients and breakpoints.</span>

<span class="sd">    The polynomial between ``x[i]`` and ``x[i + 1]`` is written in the</span>
<span class="sd">    Bernstein polynomial basis::</span>

<span class="sd">        S = sum(c[a, i] * b(a, k; x) for a in range(k+1)),</span>

<span class="sd">    where ``k`` is the degree of the polynomial, and::</span>

<span class="sd">        b(a, k; x) = binom(k, a) * t**a * (1 - t)**(k - a),</span>

<span class="sd">    with ``t = (x - x[i]) / (x[i+1] - x[i])`` and ``binom`` is the binomial</span>
<span class="sd">    coefficient.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : ndarray, shape (k, m, ...)</span>
<span class="sd">        Polynomial coefficients, order `k` and `m` intervals</span>
<span class="sd">    x : ndarray, shape (m+1,)</span>
<span class="sd">        Polynomial breakpoints. Must be sorted in either increasing or</span>
<span class="sd">        decreasing order.</span>
<span class="sd">    extrapolate : bool, optional</span>
<span class="sd">        If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">        based on first and last intervals, or to return NaNs. If &#39;periodic&#39;,</span>
<span class="sd">        periodic extrapolation is used. Default is True.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Interpolation axis. Default is zero.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Breakpoints.</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Coefficients of the polynomials. They are reshaped</span>
<span class="sd">        to a 3-D array with the last dimension representing</span>
<span class="sd">        the trailing dimensions of the original coefficient array.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Interpolation axis.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>
<span class="sd">    extend</span>
<span class="sd">    derivative</span>
<span class="sd">    antiderivative</span>
<span class="sd">    integrate</span>
<span class="sd">    construct_fast</span>
<span class="sd">    from_power_basis</span>
<span class="sd">    from_derivatives</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    PPoly : piecewise polynomials in the power basis</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Properties of Bernstein polynomials are well documented in the literature,</span>
<span class="sd">    see for example [1]_ [2]_ [3]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://en.wikipedia.org/wiki/Bernstein_polynomial</span>

<span class="sd">    .. [2] Kenneth I. Joy, Bernstein polynomials,</span>
<span class="sd">       http://www.idav.ucdavis.edu/education/CAGDNotes/Bernstein-Polynomials.pdf</span>

<span class="sd">    .. [3] E. H. Doha, A. H. Bhrawy, and M. A. Saker, Boundary Value Problems,</span>
<span class="sd">           vol 2011, article ID 829546, :doi:`10.1155/2011/829543`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import BPoly</span>
<span class="sd">    &gt;&gt;&gt; x = [0, 1]</span>
<span class="sd">    &gt;&gt;&gt; c = [[1], [2], [3]]</span>
<span class="sd">    &gt;&gt;&gt; bp = BPoly(c, x)</span>

<span class="sd">    This creates a 2nd order polynomial</span>

<span class="sd">    .. math::</span>

<span class="sd">        B(x) = 1 \\times b_{0, 2}(x) + 2 \\times b_{1, 2}(x) + 3</span>
<span class="sd">               \\times b_{2, 2}(x) \\\\</span>
<span class="sd">             = 1 \\times (1-x)^2 + 2 \\times 2 x (1 - x) + 3 \\times x^2</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">evaluate_bernstein</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of derivative to evaluate. Default is 1, i.e., compute the</span>
<span class="sd">            first derivative. If negative, the antiderivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bp : BPoly</span>
<span class="sd">            Piecewise polynomial of order k - nu representing the derivative of</span>
<span class="sd">            this polynomial.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
                <span class="n">bp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">derivative</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">bp</span>

        <span class="c1"># reduce order</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For a polynomial</span>
            <span class="c1">#    B(x) = \sum_{a=0}^{k} c_a b_{a, k}(x),</span>
            <span class="c1"># we use the fact that</span>
            <span class="c1">#   b&#39;_{a, k} = k ( b_{a-1, k-1} - b_{a, k-1} ),</span>
            <span class="c1"># which leads to</span>
            <span class="c1">#   B&#39;(x) = \sum_{a=0}^{k-1} (c_{a+1} - c_a) b_{a, k-1}</span>
            <span class="c1">#</span>
            <span class="c1"># finally, for an interval [y, y + dy] with dy != 1,</span>
            <span class="c1"># we need to correct for an extra power of dy</span>

            <span class="n">rest</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)[(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span><span class="o">+</span><span class="n">rest</span><span class="p">]</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">dx</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># derivative of order 0 is zero</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># construct a compatible polynomial</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the antiderivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : int, optional</span>
<span class="sd">            Order of antiderivative to evaluate. Default is 1, i.e., compute</span>
<span class="sd">            the first integral. If negative, the derivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bp : BPoly</span>
<span class="sd">            Piecewise polynomial of order k + nu representing the</span>
<span class="sd">            antiderivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If antiderivative is computed and ``self.extrapolate=&#39;periodic&#39;``,</span>
<span class="sd">        it will be set to False for the returned instance. This is done because</span>
<span class="sd">        the antiderivative is no longer periodic and its correct evaluation</span>
<span class="sd">        outside of the initially given x interval is difficult.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nu</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
                <span class="n">bp</span> <span class="o">=</span> <span class="n">bp</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">bp</span>

        <span class="c1"># Construct the indefinite integrals on individual intervals</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">c2</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">*=</span> <span class="n">delta</span><span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Now fix continuity: on the very first interval, take the integration</span>
        <span class="c1"># constant to be zero; on an interval [x_j, x_{j+1}) with j&gt;0,</span>
        <span class="c1"># the integration constant is then equal to the jump of the `bp` at x_j.</span>
        <span class="c1"># The latter is given by the coefficient of B_{n+1, n+1}</span>
        <span class="c1"># *on the previous interval* (other B. polynomials are zero at the</span>
        <span class="c1"># breakpoint). Finally, use the fact that BPs form a partition of unity.</span>
        <span class="n">c2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">c2</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a definite integral over a piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : float</span>
<span class="sd">            Lower integration bound</span>
<span class="sd">        b : float</span>
<span class="sd">            Upper integration bound</span>
<span class="sd">        extrapolate : {bool, &#39;periodic&#39;, None}, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs. If &#39;periodic&#39;, periodic</span>
<span class="sd">            extrapolation is used. If None (default), use `self.extrapolate`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array_like</span>
<span class="sd">            Definite integral of the piecewise polynomial over [a, b]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: can probably use instead the fact that</span>
        <span class="c1"># \int_0^{1} B_{j, n}(x) \dx = 1/(n+1)</span>
        <span class="n">ib</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="c1"># ib.extrapolate shouldn&#39;t be &#39;periodic&#39;, it is converted to</span>
        <span class="c1"># False for &#39;periodic. in antiderivative() call.</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">!=</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="n">ib</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="o">==</span> <span class="s1">&#39;periodic&#39;</span><span class="p">:</span>
            <span class="c1"># Split the integral into the part over period (can be several</span>
            <span class="c1"># of them) and the remaining part.</span>

            <span class="c1"># For simplicity and clarity convert to a &lt;= b case.</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="n">xs</span><span class="p">,</span> <span class="n">xe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">xe</span> <span class="o">-</span> <span class="n">xs</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
            <span class="n">n_periods</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">n_periods</span> <span class="o">*</span> <span class="p">(</span><span class="n">ib</span><span class="p">(</span><span class="n">xe</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>

            <span class="c1"># Map a and b to [xs, xe].</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">xs</span><span class="p">)</span> <span class="o">%</span> <span class="n">period</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">left</span>

            <span class="c1"># If b &lt;= xe then we need to integrate over [a, b], otherwise</span>
            <span class="c1"># over [a, xe] and from xs to what is remained.</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">xe</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">ib</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">ib</span><span class="p">(</span><span class="n">xe</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">ib</span><span class="p">(</span><span class="n">xs</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">a</span> <span class="o">-</span> <span class="n">xe</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ib</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">ib</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_degree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_degree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">_PPolyBase</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">extend</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">_PPolyBase</span><span class="o">.</span><span class="n">extend</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_power_basis</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pp</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a piecewise polynomial in Bernstein basis</span>
<span class="sd">        from a power basis polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            A piecewise polynomial in the power basis</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pp</span><span class="p">,</span> <span class="n">PPoly</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;.from_power_basis only accepts PPoly instances. &quot;</span>
                            <span class="s2">&quot;Got </span><span class="si">%s</span><span class="s2"> instead.&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">pp</span><span class="p">))</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>   <span class="c1"># polynomial order</span>

        <span class="n">rest</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">/</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span><span class="o">+</span><span class="n">rest</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">extrapolate</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_derivatives</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a piecewise polynomial in the Bernstein basis,</span>
<span class="sd">        compatible with the specified values and derivatives at breakpoints.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xi : array_like</span>
<span class="sd">            sorted 1-D array of x-coordinates</span>
<span class="sd">        yi : array_like or list of array_likes</span>
<span class="sd">            ``yi[i][j]`` is the ``j``\\ th derivative known at ``xi[i]``</span>
<span class="sd">        orders : None or int or array_like of ints. Default: None.</span>
<span class="sd">            Specifies the degree of local polynomials. If not None, some</span>
<span class="sd">            derivatives are ignored.</span>
<span class="sd">        extrapolate : bool or &#39;periodic&#39;, optional</span>
<span class="sd">            If bool, determines whether to extrapolate to out-of-bounds points</span>
<span class="sd">            based on first and last intervals, or to return NaNs.</span>
<span class="sd">            If &#39;periodic&#39;, periodic extrapolation is used. Default is True.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``k`` derivatives are specified at a breakpoint ``x``, the</span>
<span class="sd">        constructed polynomial is exactly ``k`` times continuously</span>
<span class="sd">        differentiable at ``x``, unless the ``order`` is provided explicitly.</span>
<span class="sd">        In the latter case, the smoothness of the polynomial at</span>
<span class="sd">        the breakpoint is controlled by the ``order``.</span>

<span class="sd">        Deduces the number of derivatives to match at each end</span>
<span class="sd">        from ``order`` and the number of derivatives available. If</span>
<span class="sd">        possible it uses the same number of derivatives from</span>
<span class="sd">        each end; if the number is odd it tries to take the</span>
<span class="sd">        extra one from y2. In any case if not enough derivatives</span>
<span class="sd">        are available at one end or another it draws enough to</span>
<span class="sd">        make up the total from the other end.</span>

<span class="sd">        If the order is too high and not enough derivatives are available,</span>
<span class="sd">        an exception is raised.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from scipy.interpolate import BPoly</span>
<span class="sd">        &gt;&gt;&gt; BPoly.from_derivatives([0, 1], [[1, 2], [3, 4]])</span>

<span class="sd">        Creates a polynomial `f(x)` of degree 3, defined on `[0, 1]`</span>
<span class="sd">        such that `f(0) = 1, df/dx(0) = 2, f(1) = 3, df/dx(1) = 4`</span>

<span class="sd">        &gt;&gt;&gt; BPoly.from_derivatives([0, 1, 2], [[0, 1], [0], [2]])</span>

<span class="sd">        Creates a piecewise polynomial `f(x)`, such that</span>
<span class="sd">        `f(0) = f(1) = 0`, `f(2) = 2`, and `df/dx(0) = 1`.</span>
<span class="sd">        Based on the number of derivatives provided, the order of the</span>
<span class="sd">        local polynomials is 2 on `[0, 1]` and 1 on `[1, 2]`.</span>
<span class="sd">        Notice that no restriction is imposed on the derivatives at</span>
<span class="sd">        ``x = 1`` and ``x = 2``.</span>

<span class="sd">        Indeed, the explicit form of the polynomial is::</span>

<span class="sd">            f(x) = | x * (1 - x),  0 &lt;= x &lt; 1</span>
<span class="sd">                   | 2 * (x - 1),  1 &lt;= x &lt;= 2</span>

<span class="sd">        So that f&#39;(1-0) = -1 and f&#39;(1+0) = 2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xi and yi need to have the same length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x coordinates are not in increasing order&quot;</span><span class="p">)</span>

        <span class="c1"># number of intervals</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># global poly order is k-1, local orders are &lt;=k and can vary</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Using a 1-D array for y? Please .reshape(-1, 1).&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="k">if</span> <span class="n">orders</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orders</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                <span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="n">orders</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">orders</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">o</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orders</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Orders must be positive.&quot;</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">yi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">))</span>
                <span class="n">n2</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">n2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">n1</span><span class="o">+</span><span class="n">n2</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                    <span class="n">mesg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Point </span><span class="si">%g</span><span class="s2"> has </span><span class="si">%d</span><span class="s2"> derivatives, point </span><span class="si">%g</span><span class="s2">&quot;</span>
                            <span class="s2">&quot; has </span><span class="si">%d</span><span class="s2"> derivatives, but order </span><span class="si">%d</span><span class="s2"> requested&quot;</span> <span class="o">%</span> <span class="p">(</span>
                               <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">),</span> <span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">mesg</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n2</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y2</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`order` input incompatible with&quot;</span>
                                     <span class="s2">&quot; length y1 or y2.&quot;</span><span class="p">)</span>

            <span class="n">b</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">_construct_from_derivatives</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                                  <span class="n">y1</span><span class="p">[:</span><span class="n">n1</span><span class="p">],</span> <span class="n">y2</span><span class="p">[:</span><span class="n">n2</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">BPoly</span><span class="o">.</span><span class="n">_raise_degree</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">xi</span><span class="p">,</span> <span class="n">extrapolate</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_construct_from_derivatives</span><span class="p">(</span><span class="n">xa</span><span class="p">,</span> <span class="n">xb</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute the coefficients of a polynomial in the Bernstein basis</span>
<span class="sd">        given the values and derivatives at the edges.</span>

<span class="sd">        Return the coefficients of a polynomial in the Bernstein basis</span>
<span class="sd">        defined on ``[xa, xb]`` and having the values and derivatives at the</span>
<span class="sd">        endpoints `xa` and `xb` as specified by `ya` and `yb`.</span>
<span class="sd">        The polynomial constructed is of the minimal possible degree, i.e.,</span>
<span class="sd">        if the lengths of `ya` and `yb` are `na` and `nb`, the degree</span>
<span class="sd">        of the polynomial is ``na + nb - 1``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xa : float</span>
<span class="sd">            Left-hand end point of the interval</span>
<span class="sd">        xb : float</span>
<span class="sd">            Right-hand end point of the interval</span>
<span class="sd">        ya : array_like</span>
<span class="sd">            Derivatives at `xa`. ``ya[0]`` is the value of the function, and</span>
<span class="sd">            ``ya[i]`` for ``i &gt; 0`` is the value of the ``i``\ th derivative.</span>
<span class="sd">        yb : array_like</span>
<span class="sd">            Derivatives at `xb`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            coefficient array of a polynomial having specified derivatives</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This uses several facts from life of Bernstein basis functions.</span>
<span class="sd">        First of all,</span>

<span class="sd">            .. math:: b&#39;_{a, n} = n (b_{a-1, n-1} - b_{a, n-1})</span>

<span class="sd">        If B(x) is a linear combination of the form</span>

<span class="sd">            .. math:: B(x) = \sum_{a=0}^{n} c_a b_{a, n},</span>

<span class="sd">        then :math: B&#39;(x) = n \sum_{a=0}^{n-1} (c_{a+1} - c_{a}) b_{a, n-1}.</span>
<span class="sd">        Iterating the latter one, one finds for the q-th derivative</span>

<span class="sd">            .. math:: B^{q}(x) = n!/(n-q)! \sum_{a=0}^{n-q} Q_a b_{a, n-q},</span>

<span class="sd">        with</span>

<span class="sd">          .. math:: Q_a = \sum_{j=0}^{q} (-)^{j+q} comb(q, j) c_{j+a}</span>

<span class="sd">        This way, only `a=0` contributes to :math: `B^{q}(x = xa)`, and</span>
<span class="sd">        `c_q` are found one by one by iterating `q = 0, ..., na`.</span>

<span class="sd">        At ``x = xb`` it&#39;s the same with ``a = n - q``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ya</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ya</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">yb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Shapes of ya </span><span class="si">{</span><span class="n">ya</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and yb </span><span class="si">{</span><span class="n">yb</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> are incompatible&quot;</span>
            <span class="p">)</span>

        <span class="n">dta</span><span class="p">,</span> <span class="n">dtb</span> <span class="o">=</span> <span class="n">ya</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">yb</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> <span class="ow">or</span>
               <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtb</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)):</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

        <span class="n">na</span><span class="p">,</span> <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ya</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">na</span> <span class="o">+</span> <span class="n">nb</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">na</span><span class="o">+</span><span class="n">nb</span><span class="p">,)</span> <span class="o">+</span> <span class="n">ya</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

        <span class="c1"># compute coefficients of a polynomial degree na+nb-1</span>
        <span class="c1"># walk left-to-right</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">na</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">ya</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">/</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xb</span> <span class="o">-</span> <span class="n">xa</span><span class="p">)</span><span class="o">**</span><span class="n">q</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c1"># now walk right-to-left</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yb</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">/</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">q</span> <span class="o">*</span> <span class="p">(</span><span class="n">xb</span> <span class="o">-</span> <span class="n">xa</span><span class="p">)</span><span class="o">**</span><span class="n">q</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">q</span><span class="o">+</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">c</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_raise_degree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Raise a degree of a polynomial in the Bernstein basis.</span>

<span class="sd">        Given the coefficients of a polynomial degree `k`, return (the</span>
<span class="sd">        coefficients of) the equivalent polynomial of degree `k+d`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c : array_like</span>
<span class="sd">            coefficient array, 1-D</span>
<span class="sd">        d : integer</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array</span>
<span class="sd">            coefficient array, 1-D array of length `c.shape[0] + d`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This uses the fact that a Bernstein polynomial `b_{a, k}` can be</span>
<span class="sd">        identically represented as a linear combination of polynomials of</span>
<span class="sd">        a higher degree `k+d`:</span>

<span class="sd">            .. math:: b_{a, k} = comb(k, a) \sum_{j=0}^{d} b_{a+j, k+d} \</span>
<span class="sd">                                 comb(d, j) / comb(k+d, a+j)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">c</span>

        <span class="n">k</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">comb</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">comb</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>


<span class="k">class</span> <span class="nc">NdPPoly</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Piecewise tensor product polynomial</span>

<span class="sd">    The value at point ``xp = (x&#39;, y&#39;, z&#39;, ...)`` is evaluated by first</span>
<span class="sd">    computing the interval indices `i` such that::</span>

<span class="sd">        x[0][i[0]] &lt;= x&#39; &lt; x[0][i[0]+1]</span>
<span class="sd">        x[1][i[1]] &lt;= y&#39; &lt; x[1][i[1]+1]</span>
<span class="sd">        ...</span>

<span class="sd">    and then computing::</span>

<span class="sd">        S = sum(c[k0-m0-1,...,kn-mn-1,i[0],...,i[n]]</span>
<span class="sd">                * (xp[0] - x[0][i[0]])**m0</span>
<span class="sd">                * ...</span>
<span class="sd">                * (xp[n] - x[n][i[n]])**mn</span>
<span class="sd">                for m0 in range(k[0]+1)</span>
<span class="sd">                ...</span>
<span class="sd">                for mn in range(k[n]+1))</span>

<span class="sd">    where ``k[j]`` is the degree of the polynomial in dimension j. This</span>
<span class="sd">    representation is the piecewise multivariate power basis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : ndarray, shape (k0, ..., kn, m0, ..., mn, ...)</span>
<span class="sd">        Polynomial coefficients, with polynomial order `kj` and</span>
<span class="sd">        `mj+1` intervals for each dimension `j`.</span>
<span class="sd">    x : ndim-tuple of ndarrays, shapes (mj+1,)</span>
<span class="sd">        Polynomial breakpoints for each dimension. These must be</span>
<span class="sd">        sorted in increasing order.</span>
<span class="sd">    extrapolate : bool, optional</span>
<span class="sd">        Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">        and last intervals, or to return NaNs. Default: True.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    x : tuple of ndarrays</span>
<span class="sd">        Breakpoints.</span>
<span class="sd">    c : ndarray</span>
<span class="sd">        Coefficients of the polynomials.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    __call__</span>
<span class="sd">    derivative</span>
<span class="sd">    antiderivative</span>
<span class="sd">    integrate</span>
<span class="sd">    integrate_1d</span>
<span class="sd">    construct_fast</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    PPoly : piecewise polynomials in 1D</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    High-order polynomials in the power basis can be numerically</span>
<span class="sd">    unstable.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x arrays must all be 1-dimensional&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x arrays must all contain at least 2 points&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;c must have at least 2*len(x) dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x-coordinates are not in increasing order&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and c do not agree on the number of intervals&quot;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">construct_fast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the piecewise polynomial without making checks.</span>

<span class="sd">        Takes the same parameters as the constructor. Input arguments</span>
<span class="sd">        ``c`` and ``x`` must be arrays of the correct shape and type.  The</span>
<span class="sd">        ``c`` array can only be of dtypes float and complex, and ``x``</span>
<span class="sd">        array must have dtype float.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span> <span class="o">=</span> <span class="n">extrapolate</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_get_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> \
               <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="k">def</span> <span class="nf">_ensure_c_contiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the piecewise polynomial or its derivative</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            Points to evaluate the interpolant at.</span>
<span class="sd">        nu : tuple, optional</span>
<span class="sd">            Orders of derivatives to evaluate. Each must be non-negative.</span>
<span class="sd">        extrapolate : bool, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : array-like</span>
<span class="sd">            Interpolated values. Shape is determined by replacing</span>
<span class="sd">            the interpolation axis in the original array with the shape of x.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals are considered half-open,</span>
<span class="sd">        ``[a, b)``, except for the last interval which is closed</span>
<span class="sd">        ``[a, b]``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">_ndim_coords_from_arrays</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndim</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nu</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">nu</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid number of derivative orders nu&quot;</span><span class="p">)</span>

        <span class="n">dim1</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">ndim</span><span class="p">])</span>
        <span class="n">dim2</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ndim</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">])</span>
        <span class="n">dim3</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">:])</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">ndim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="n">_ppoly</span><span class="o">.</span><span class="n">evaluate_nd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span><span class="p">,</span> <span class="n">dim3</span><span class="p">),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                           <span class="n">ks</span><span class="p">,</span>
                           <span class="n">x</span><span class="p">,</span>
                           <span class="n">nu</span><span class="p">,</span>
                           <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">),</span>
                           <span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">ndim</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">_derivative_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute 1-D derivative along a selected dimension in-place</span>
<span class="sd">        May result to non-contiguous c array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_antiderivative_inplace</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">ndim</span>

        <span class="c1"># reduce order</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># noop</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># derivative of order 0 is zero</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># multiply by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">c2</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c2</span>

    <span class="k">def</span> <span class="nf">_antiderivative_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute 1-D antiderivative along a selected dimension</span>
<span class="sd">        May result to non-contiguous c array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nu</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative_inplace</span><span class="p">(</span><span class="o">-</span><span class="n">nu</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">%</span> <span class="n">ndim</span>

        <span class="n">perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">perm</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nu</span><span class="p">,)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                     <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">c2</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>

        <span class="c1"># divide by the correct rising factorials</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">poch</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">nu</span><span class="p">)</span>
        <span class="n">c2</span><span class="p">[:</span><span class="o">-</span><span class="n">nu</span><span class="p">]</span> <span class="o">/=</span> <span class="n">factor</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># fix continuity of added degrees of freedom</span>
        <span class="n">perm2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">perm2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">perm2</span><span class="p">[</span><span class="n">ndim</span><span class="o">+</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm2</span><span class="p">[</span><span class="n">ndim</span><span class="o">+</span><span class="n">axis</span><span class="p">],</span> <span class="n">perm2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm2</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_ppoly</span><span class="o">.</span><span class="n">fix_continuity</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">nu</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm2</span><span class="p">)</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">c2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

        <span class="c1"># Done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c2</span>

    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the derivative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : ndim-tuple of int</span>
<span class="sd">            Order of derivatives to evaluate for each dimension.</span>
<span class="sd">            If negative, the antiderivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : NdPPoly</span>
<span class="sd">            Piecewise polynomial of orders (k[0] - nu[0], ..., k[n] - nu[n])</span>
<span class="sd">            representing the derivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Derivatives are evaluated piecewise for each polynomial</span>
<span class="sd">        segment, even if the polynomial is not differentiable at the</span>
<span class="sd">        breakpoints. The polynomial intervals in each dimension are</span>
<span class="sd">        considered half-open, ``[a, b)``, except for the last interval</span>
<span class="sd">        which is closed ``[a, b]``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">_derivative_inplace</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">antiderivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new piecewise polynomial representing the antiderivative.</span>

<span class="sd">        Antiderivative is also the indefinite integral of the function,</span>
<span class="sd">        and derivative is its inverse operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nu : ndim-tuple of int</span>
<span class="sd">            Order of derivatives to evaluate for each dimension.</span>
<span class="sd">            If negative, the derivative is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pp : PPoly</span>
<span class="sd">            Piecewise polynomial of order k2 = k + n representing</span>
<span class="sd">            the antiderivative of this polynomial.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The antiderivative returned by this function is continuous and</span>
<span class="sd">        continuously differentiable to order n-1, up to floating point</span>
<span class="sd">        rounding error.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nu</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">_antiderivative_inplace</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">integrate_1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute NdPPoly representation for one dimensional definite integral</span>

<span class="sd">        The result is a piecewise polynomial representing the integral:</span>

<span class="sd">        .. math::</span>

<span class="sd">           p(y, z, ...) = \int_a^b dx\, p(x, y, z, ...)</span>

<span class="sd">        where the dimension integrated over is specified with the</span>
<span class="sd">        `axis` parameter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b : float</span>
<span class="sd">            Lower and upper bound for integration.</span>
<span class="sd">        axis : int</span>
<span class="sd">            Dimension over which to compute the 1-D integrals</span>
<span class="sd">        extrapolate : bool, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ig : NdPPoly or array-like</span>
<span class="sd">            Definite integral of the piecewise polynomial over [a, b].</span>
<span class="sd">            If the polynomial was 1D, an array is returned,</span>
<span class="sd">            otherwise, an NdPPoly object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">%</span> <span class="n">ndim</span>

        <span class="c1"># reuse 1-D integration routines</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="n">swap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">swap</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">swap</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">swap</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">swap</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">+</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">swap</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">PPoly</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span>
                                 <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="c1"># Construct result</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a definite integral over a piecewise polynomial.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ranges : ndim-tuple of 2-tuples float</span>
<span class="sd">            Sequence of lower and upper bounds for each dimension,</span>
<span class="sd">            ``[(a[0], b[0]), ..., (a[ndim-1], b[ndim-1])]``</span>
<span class="sd">        extrapolate : bool, optional</span>
<span class="sd">            Whether to extrapolate to out-of-bounds points based on first</span>
<span class="sd">            and last intervals, or to return NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ig : array_like</span>
<span class="sd">            Definite integral of the piecewise polynomial over</span>
<span class="sd">            [a[0], b[0]] x ... x [a[ndim-1], b[ndim-1]]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extrapolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extrapolate</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">extrapolate</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ranges</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Range not a sequence of correct length&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_c_contiguous</span><span class="p">()</span>

        <span class="c1"># Reuse 1D integration routine</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ranges</span><span class="p">):</span>
            <span class="n">swap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="n">swap</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">n</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">swap</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">swap</span><span class="p">)</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">PPoly</span><span class="o">.</span><span class="n">construct_fast</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>

        <span class="k">return</span> <span class="n">c</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Maty Novk &amp; Jano Minr.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>